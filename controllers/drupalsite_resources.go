/*
Copyright 2021 CERN.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
	"context"
	"crypto/md5"
	"encoding/hex"
	"fmt"
	"io/ioutil"
	"math/rand"
	"net/url"
	"path"
	"strconv"
	"time"

	"github.com/go-logr/logr"
	buildv1 "github.com/openshift/api/build/v1"
	imagev1 "github.com/openshift/api/image/v1"
	routev1 "github.com/openshift/api/route/v1"

	dbodv1a1 "gitlab.cern.ch/drupal/paas/dbod-operator/api/v1alpha1"
	webservicesv1a1 "gitlab.cern.ch/drupal/paas/drupalsite-operator/api/v1alpha1"
	authz "gitlab.cern.ch/paas-tools/operators/authz-operator/api/v1alpha1"
	appsv1 "k8s.io/api/apps/v1"
	batchv1 "k8s.io/api/batch/v1"
	corev1 "k8s.io/api/core/v1"
	v1 "k8s.io/api/core/v1"
	rbacv1 "k8s.io/api/rbac/v1"
	k8sapierrors "k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/util/intstr"
	"k8s.io/utils/pointer"
	controllerruntime "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"

	pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
	velerov1 "github.com/vmware-tanzu/velero/pkg/apis/velero/v1"
)

// Const vars
const (
	// Variable used to define Default WebDAV login Username
	webDAVDefaultLogin string = "admin"
	// Variable to set the used Memory for all Jobs generated by the Operator
	jobMemoryRequest string = "512Mi"
)

var (
	// BuildResources are the resource requests/limits for the image builds. Set during initEnv()
	BuildResources corev1.ResourceRequirements
)

/*
ensureResources ensures the presence of all the resources that the DrupalSite needs to serve content.
This includes BuildConfigs/ImageStreams, DB, PVC, PHP/Nginx deployment + service, site install job, Routes.
*/
func (r *DrupalSiteReconciler) ensureResources(drp *webservicesv1a1.DrupalSite, deploymentConfig DeploymentConfig, log logr.Logger) (transientErrs []reconcileError) {
	ctx := context.TODO()

	// 1. BuildConfigs and ImageStreams

	if len(drp.Spec.Configuration.ExtraConfigurationRepo) > 0 {
		if transientErr := r.ensureResourceX(ctx, drp, "is_s2i", log); transientErr != nil {
			transientErrs = append(transientErrs, transientErr.Wrap("%v: for S2I SiteBuilder ImageStream"))
		}
		if transientErr := r.ensureResourceX(ctx, drp, "bc_s2i", log); transientErr != nil {
			transientErrs = append(transientErrs, transientErr.Wrap("%v: for S2I SiteBuilder BuildConfig"))
		}
		if transientErr := r.ensureResourceX(ctx, drp, "gitlab_trigger_secret", log); transientErr != nil {
			transientErrs = append(transientErrs, transientErr.Wrap("%v: for S2I SiteBuilder Secret"))
		}
	}
	// 2. Data layer

	if transientErr := r.ensureResourceX(ctx, drp, "pvc_drupal", log); transientErr != nil {
		transientErrs = append(transientErrs, transientErr.Wrap("%v: for Drupal PVC"))
	}
	if transientErr := r.ensureResourceX(ctx, drp, "dbod_cr", log); transientErr != nil {
		transientErrs = append(transientErrs, transientErr.Wrap("%v: for DBOD resource"))
	}
	if transientErr := r.ensureResourceX(ctx, drp, "webdav_secret", log); transientErr != nil {
		transientErrs = append(transientErrs, transientErr.Wrap("%v: for WebDAV Secret"))
	}

	// 3. Serving layer

	if transientErr := r.ensureResourceX(ctx, drp, "cm_php", log); transientErr != nil {
		transientErrs = append(transientErrs, transientErr.Wrap("%v: for PHP-FPM CM"))
	}
	if transientErr := r.ensureResourceX(ctx, drp, "cm_nginx_global", log); transientErr != nil {
		transientErrs = append(transientErrs, transientErr.Wrap("%v: for Nginx CM"))
	}
	if transientErr := r.ensureResourceX(ctx, drp, "cm_settings", log); transientErr != nil {
		transientErrs = append(transientErrs, transientErr.Wrap("%v: for settings.php CM"))
	}
	if transientErr := r.ensureResourceX(ctx, drp, "cm_php_cli", log); transientErr != nil {
		transientErrs = append(transientErrs, transientErr.Wrap("%v: for PHP Job CM"))
	}
	if r.isDBODProvisioned(ctx, drp) {
		if transientErr := r.ensureDrupalDeployment(ctx, drp, deploymentConfig, log); transientErr != nil {
			transientErrs = append(transientErrs, transientErr.Wrap("%v: for Drupal deployment"))
		}
	}
	if transientErr := r.ensureResourceX(ctx, drp, "svc_nginx", log); transientErr != nil {
		transientErrs = append(transientErrs, transientErr.Wrap("%v: for Nginx SVC"))
	}
	/* A new drupalsite can be initialized with 3 different ways depending its Spec:
		- clone_job if Spec.Configuration.CloneFrom is given
		- easystart_taskrun if Spec.Configuration.Easystart equals to enable
		- site_install_job if it is a fresh site
	        Between CloneFrom and Easystart we don't care which case is checked first (undefined).
	        We use an OPA rule that prohibits both fields from being set at the same time.
	*/
	if r.isDBODProvisioned(ctx, drp) && !(drp.ConditionTrue("Initialized")) {
		switch {
		case drp.Spec.Configuration.CloneFrom != "":
			if transientErr := r.ensureResourceX(ctx, drp, "clone_job", log); transientErr != nil {
				transientErrs = append(transientErrs, transientErr.Wrap("%v: for clone Job"))
			}
		case drp.Spec.Configuration.Easystart == "enable":
			if transientErr := r.ensureResourceX(ctx, drp, "easystart_taskrun", log); transientErr != nil {
				transientErrs = append(transientErrs, transientErr.Wrap("%v: for easystart TaskRun"))
			}
		default:
			if transientErr := r.ensureResourceX(ctx, drp, "site_install_job", log); transientErr != nil {
				transientErrs = append(transientErrs, transientErr.Wrap("%v: for site install Job"))
			}
		}
	}

	// 4. Ingress

	if drp.ConditionTrue("Initialized") {
		// each function below ensures 1 route per entry in `spec.siteUrl[]`. This is understandably part of the job of "ensuring resource X".
		if transientErr := r.ensureResourceX(ctx, drp, "route", log); transientErr != nil {
			transientErrs = append(transientErrs, transientErr.Wrap("%v: for Route"))
		}
		if transientErr := r.ensureResourceX(ctx, drp, "oidc_return_uri", log); transientErr != nil {
			transientErrs = append(transientErrs, transientErr.Wrap("%v: for OidcReturnURI"))
		}

		// each function below removes any unwanted routes
		if transientErr := r.ensureNoExtraRouteResource(ctx, drp, "drupal", log); transientErr != nil {
			transientErrs = append(transientErrs, transientErr.Wrap("%v: while ensuring no extra routes"))
		}
		if transientErr := r.ensureNoExtraOidcReturnUriResource(ctx, drp, "drupal", log); transientErr != nil {
			transientErrs = append(transientErrs, transientErr.Wrap("%v: while ensuring no extra OidcReturnURIs"))
		}
	} else {
		for _, url := range drp.Spec.SiteURL {
			if transientErr := r.ensureNoRoute(ctx, drp, string(url), log); transientErr != nil {
				transientErrs = append(transientErrs, transientErr.Wrap("%v: while deleting the Route"))
			}
			if transientErr := r.ensureNoReturnURI(ctx, drp, string(url), log); transientErr != nil {
				transientErrs = append(transientErrs, transientErr.Wrap("%v: while deleting the OidcReturnURI"))
			}
		}
	}

	// 5. Cluster-scoped: Backup schedule, Tekton RBAC
	// Create Velero schedule only after site is initialized in order for the first backup to not report 'Failed' or 'PartiallyFailed' status
	if drp.ConditionTrue("Initialized") && (drp.Status.IsPrimary || drp.Spec.Configuration.ScheduledBackups == "enabled") {
		if transientErr := r.ensureResourceX(ctx, drp, "backup_schedule", log); transientErr != nil {
			transientErrs = append(transientErrs, transientErr.Wrap("%v: for Velero Schedule"))
		}
	} else {
		if transientErr := r.ensureNoBackupSchedule(ctx, drp, log); transientErr != nil {
			transientErrs = append(transientErrs, transientErr.Wrap("%v: while deleting the Velero schedule"))
		}
	}
	if transientErr := r.ensureResourceX(ctx, drp, "tekton_extra_perm_rbac", log); transientErr != nil {
		transientErrs = append(transientErrs, transientErr.Wrap("%v: for Tekton Extra Permissions ClusterRoleBinding"))
	}
	return transientErrs
}

/*
ensureResourceX ensure the requested resource is created, with the following valid values
	- pvc_drupal: PersistentVolume for the drupalsite
	- site_install_job: Kubernetes Job for the drush ensure-site-install
	- clone_job: Kubernetes Job for cloning a drupal site
	- easystart_taskrun: Taskrun for restoring easystart backup
	- is_base: ImageStream for sitebuilder-base
	- is_s2i: ImageStream for S2I sitebuilder
	- bc_s2i: BuildConfig for S2I sitebuilder
	- deploy_drupal: <moved to `ensureDrupalDeployment`>
	- svc_nginx: Service for Nginx
	- cm_php: ConfigMap for PHP-FPM
	- cm_nginx_global: ConfigMap for Nginx global settings (performance)
	- cm_settings: ConfigMap for `settings.php`
	- cm_php_cli: ConfigMap for 'config.ini' for PHP CLI
	- route: Route for the drupalsite
	- oidc_return_uri: Redirection URI for OIDC
	- dbod_cr: DBOD custom resource to establish database & respective connection for the drupalsite
	- webdav_secret: Secret with credential for WebDAV
	- backup_schedule: Velero Schedule for scheduled backups of the drupalSite
	- tekton_extra_perm_rbac: ClusterRoleBinding for tekton tasks
	- gitlab_trigger_secret: Secret for Gitlab trigger config in buildconfig
*/
func (r *DrupalSiteReconciler) ensureResourceX(ctx context.Context, d *webservicesv1a1.DrupalSite, resType string, log logr.Logger) (transientErr reconcileError) {
	switch resType {
	case "is_s2i":
		is := &imagev1.ImageStream{ObjectMeta: metav1.ObjectMeta{Name: "sitebuilder-s2i-" + d.Name, Namespace: d.Namespace}}
		_, err := controllerruntime.CreateOrUpdate(ctx, r.Client, is, func() error {
			return imageStreamForDrupalSiteBuilderS2I(is, d)
		})
		if err != nil {
			log.Error(err, "Failed to ensure Resource", "Kind", is.TypeMeta.Kind, "Resource.Namespace", is.Namespace, "Resource.Name", is.Name)
			return newApplicationError(err, ErrClientK8s)
		}
		return nil
	case "bc_s2i":
		bc := &buildv1.BuildConfig{ObjectMeta: metav1.ObjectMeta{Name: "sitebuilder-s2i-" + nameVersionHash(d), Namespace: d.Namespace}}
		// We don't really benefit from udating here, because of https://docs.openshift.com/container-platform/4.6/builds/triggering-builds-build-hooks.html#builds-configuration-change-triggers_triggering-builds-build-hooks
		_, err := controllerruntime.CreateOrUpdate(ctx, r.Client, bc, func() error {
			return buildConfigForDrupalSiteBuilderS2I(bc, d)
		})
		if err != nil {
			log.Error(err, "Failed to ensure Resource", "Kind", bc.TypeMeta.Kind, "Resource.Namespace", bc.Namespace, "Resource.Name", bc.Name)
			return newApplicationError(err, ErrClientK8s)
		}
		return nil
	case "webdav_secret":
		// TODO: secret names must be short (I believe <64 chars), and given the maximum name length of a DrupalSite (50 chars)
		// the webdav secret is too long.
		// In order to shorten this name we'll have to change the deployment to enforce the volumes.
		webdav_secret := &corev1.Secret{ObjectMeta: metav1.ObjectMeta{Name: "webdav-secret-" + d.Name, Namespace: d.Namespace}}
		_, err := controllerruntime.CreateOrUpdate(ctx, r.Client, webdav_secret, func() error {
			log.V(4).Info("Ensuring Resource", "Kind", webdav_secret.TypeMeta.Kind, "Resource.Namespace", webdav_secret.Namespace, "Resource.Name", webdav_secret.Name)
			return secretForWebDAV(webdav_secret, d)
		})
		if err != nil {
			log.Error(err, "Failed to ensure Resource", "Kind", webdav_secret.TypeMeta.Kind, "Resource.Namespace", webdav_secret.Namespace, "Resource.Name", webdav_secret.Name)
			return newApplicationError(err, ErrClientK8s)
		}
		return nil
	case "svc_nginx":
		svc := &corev1.Service{ObjectMeta: metav1.ObjectMeta{Name: d.Name, Namespace: d.Namespace}}
		_, err := controllerruntime.CreateOrUpdate(ctx, r.Client, svc, func() error {
			return serviceForDrupalSite(svc, d)
		})
		if err != nil {
			log.Error(err, "Failed to ensure Resource", "Kind", svc.TypeMeta.Kind, "Resource.Namespace", svc.Namespace, "Resource.Name", svc.Name)
			return newApplicationError(err, ErrClientK8s)
		}
		return nil
	case "pvc_drupal":
		pvc := &corev1.PersistentVolumeClaim{ObjectMeta: metav1.ObjectMeta{Name: "pv-claim-" + d.Name, Namespace: d.Namespace}}
		_, err := controllerruntime.CreateOrUpdate(ctx, r.Client, pvc, func() error {
			return persistentVolumeClaimForDrupalSite(pvc, d)
		})
		if err != nil {
			log.Error(err, "Failed to ensure Resource", "Kind", pvc.TypeMeta.Kind, "Resource.Namespace", pvc.Namespace, "Resource.Name", pvc.Name)
			return newApplicationError(err, ErrClientK8s)
		}
		return nil
	case "route":
		routeRequestList := d.Spec.SiteURL
		for _, req := range routeRequestList {
			hash := md5.Sum([]byte(req))
			route := &routev1.Route{ObjectMeta: metav1.ObjectMeta{Name: d.Name + "-" + hex.EncodeToString(hash[0:4]), Namespace: d.Namespace}}
			_, err := controllerruntime.CreateOrUpdate(ctx, r.Client, route, func() error {
				return routeForDrupalSite(route, d, string(req))
			})
			// TODO: don't throw on conflict
			if err != nil {
				log.Error(err, "Failed to ensure Resource", "Kind", route.TypeMeta.Kind, "Resource.Namespace", route.Namespace, "Resource.Name", route.Name)
				return newApplicationError(err, ErrClientK8s)
			}
		}
		return nil
	case "oidc_return_uri":
		routeRequestList := d.Spec.SiteURL
		for _, req := range routeRequestList {
			hash := md5.Sum([]byte(req))
			OidcReturnURI := &authz.OidcReturnURI{ObjectMeta: metav1.ObjectMeta{Name: d.Name + "-" + hex.EncodeToString(hash[0:4]), Namespace: d.Namespace}}
			_, err := controllerruntime.CreateOrUpdate(ctx, r.Client, OidcReturnURI, func() error {
				log.V(4).Info("Ensuring Resource", "Kind", OidcReturnURI.TypeMeta.Kind, "Resource.Namespace", OidcReturnURI.Namespace, "Resource.Name", OidcReturnURI.Name)
				return newOidcReturnURI(OidcReturnURI, d, string(req), true)
			})
			if err != nil {
				log.Error(err, "Failed to ensure Resource", "Kind", OidcReturnURI.TypeMeta.Kind, "Resource.Namespace", OidcReturnURI.Namespace, "Resource.Name", OidcReturnURI.Name)
			}
			OidcReturnURIHTTPS := &authz.OidcReturnURI{ObjectMeta: metav1.ObjectMeta{Name: d.Name + "-https-" + hex.EncodeToString(hash[0:4]), Namespace: d.Namespace}}
			_, err = controllerruntime.CreateOrUpdate(ctx, r.Client, OidcReturnURIHTTPS, func() error {
				log.V(4).Info("Ensuring Resource", "Kind", OidcReturnURIHTTPS.TypeMeta.Kind, "Resource.Namespace", OidcReturnURIHTTPS.Namespace, "Resource.Name", OidcReturnURIHTTPS.Name)
				return newOidcReturnURI(OidcReturnURIHTTPS, d, string(req), false)
			})
			if err != nil {
				log.Error(err, "Failed to ensure Resource", "Kind", OidcReturnURI.TypeMeta.Kind, "Resource.Namespace", OidcReturnURIHTTPS.Namespace, "Resource.Name", OidcReturnURIHTTPS.Name)
			}
		}
		return nil
	case "site_install_job":
		databaseSecretName := databaseSecretName(d)
		if len(databaseSecretName) == 0 {
			return nil
		}
		// TODO: this name is too long
		// change to `install-*`
		job := &batchv1.Job{ObjectMeta: metav1.ObjectMeta{Name: "ensure-site-install-" + d.Name, Namespace: d.Namespace}}
		_, err := controllerruntime.CreateOrUpdate(ctx, r.Client, job, func() error {
			return jobForDrupalSiteInstallation(job, databaseSecretName, d)
		})
		if err != nil {
			log.Error(err, "Failed to ensure Resource", "Kind", job.TypeMeta.Kind, "Resource.Namespace", job.Namespace, "Resource.Name", job.Name)
			return newApplicationError(err, ErrClientK8s)
		}
		return nil
	case "clone_job":
		if databaseSecret := databaseSecretName(d); len(databaseSecret) != 0 {
			job := &batchv1.Job{ObjectMeta: metav1.ObjectMeta{Name: "clone-" + d.Name, Namespace: d.Namespace}}
			_, err := controllerruntime.CreateOrUpdate(ctx, r.Client, job, func() error {
				log.V(4).Info("Ensuring Resource", "Kind", job.TypeMeta.Kind, "Resource.Namespace", job.Namespace, "Resource.Name", job.Name)
				return jobForDrupalSiteClone(job, databaseSecret, d)
			})
			if err != nil {
				log.Error(err, "Failed to ensure Resource", "Kind", job.TypeMeta.Kind, "Resource.Namespace", job.Namespace, "Resource.Name", job.Name)
				return newApplicationError(err, ErrClientK8s)
			}
		}
		return nil
	case "easystart_taskrun":
		if databaseSecret := databaseSecretName(d); len(databaseSecret) != 0 {
			taskRun := &pipelinev1.TaskRun{
				ObjectMeta: metav1.ObjectMeta{Name: "easystart-" + d.Name, Namespace: d.Namespace}}
			_, err := controllerruntime.CreateOrUpdate(ctx, r.Client, taskRun, func() error {
				log.V(4).Info("Ensuring Resource", "Kind", taskRun.TypeMeta.Kind, "Resource.Namespace", taskRun.Namespace, "Resource.Name", taskRun.Name)
				return taskRunForEasystartRestore(taskRun, d)
			})
			if err != nil {
				log.Error(err, "Failed to ensure Resource", "Kind", taskRun.TypeMeta.Kind, "Resource.Namespace", taskRun.Namespace, "Resource.Name", taskRun.Name)
				return newApplicationError(err, ErrClientK8s)
			}
		}
		return nil
	case "cm_php":
		cm := &corev1.ConfigMap{ObjectMeta: metav1.ObjectMeta{Name: "php-fpm-" + d.Name, Namespace: d.Namespace}}
		_, err := controllerruntime.CreateOrUpdate(ctx, r.Client, cm, func() error {
			return updateConfigMapForPHPFPM(ctx, cm, d, r.Client)
		})
		if err != nil {
			log.Error(err, "Failed to ensure Resource", "Kind", cm.TypeMeta.Kind, "Resource.Namespace", cm.Namespace, "Resource.Name", cm.Name)
			return newApplicationError(err, ErrClientK8s)
		}
		return nil
	case "cm_nginx_global":
		cm := &corev1.ConfigMap{ObjectMeta: metav1.ObjectMeta{Name: "nginx-global-" + d.Name, Namespace: d.Namespace}}
		_, err := controllerruntime.CreateOrUpdate(ctx, r.Client, cm, func() error {
			return updateConfigMapForNginxGlobal(ctx, cm, d, r.Client)
		})
		if err != nil {
			log.Error(err, "Failed to ensure Resource", "Kind", cm.TypeMeta.Kind, "Resource.Namespace", cm.Namespace, "Resource.Name", cm.Name)
			return newApplicationError(err, ErrClientK8s)
		}
		return nil
	case "cm_settings":
		// TODO: configmap names must be short (I believe <64 chars), and given the maximum name length of a DrupalSite (50 chars), this is too long
		// In order to shorten this name we'll have to change the deployment to enforce the volumes.
		cm := &corev1.ConfigMap{ObjectMeta: metav1.ObjectMeta{Name: "site-settings-" + d.Name, Namespace: d.Namespace}}
		_, err := controllerruntime.CreateOrUpdate(ctx, r.Client, cm, func() error {
			return updateConfigMapForSiteSettings(ctx, cm, d, r.Client)
		})
		if err != nil {
			log.Error(err, "Failed to ensure Resource", "Kind", cm.TypeMeta.Kind, "Resource.Namespace", cm.Namespace, "Resource.Name", cm.Name)
			return newApplicationError(err, ErrClientK8s)
		}
		return nil
	case "cm_php_cli":
		// TODO: configmap names must be short (I believe <64 chars), and given the maximum name length of a DrupalSite (50 chars), this is too long
		// In order to shorten this name we'll have to change the deployment to enforce the volumes.
		cm := &corev1.ConfigMap{ObjectMeta: metav1.ObjectMeta{Name: "php-cli-config-" + d.Name, Namespace: d.Namespace}}
		_, err := controllerruntime.CreateOrUpdate(ctx, r.Client, cm, func() error {
			return updateConfigMapForPHPCLI(ctx, cm, d, r.Client)
		})
		if err != nil {
			log.Error(err, "Failed to ensure Resource", "Kind", cm.TypeMeta.Kind, "Resource.Namespace", cm.Namespace, "Resource.Name", cm.Name)
			return newApplicationError(err, ErrClientK8s)
		}
		return nil
	case "dbod_cr":
		dbod := &dbodv1a1.Database{ObjectMeta: metav1.ObjectMeta{Name: d.Name, Namespace: d.Namespace}}
		_, err := controllerruntime.CreateOrUpdate(ctx, r.Client, dbod, func() error {
			return dbodForDrupalSite(dbod, d)
		})
		if err != nil {
			log.Error(err, "Failed to ensure Resource", "Kind", dbod.TypeMeta.Kind, "Resource.Namespace", dbod.Namespace, "Resource.Name", dbod.Name)
			return newApplicationError(err, ErrClientK8s)
		}
		return nil
	case "backup_schedule":
		schedule := &velerov1.Schedule{ObjectMeta: metav1.ObjectMeta{Name: generateScheduleName(d.Namespace, d.Name), Namespace: VeleroNamespace}}
		_, err := controllerruntime.CreateOrUpdate(ctx, r.Client, schedule, func() error {
			return scheduledBackupsForDrupalSite(schedule, d)
		})
		if err != nil {
			log.Error(err, "Failed to ensure Resource", "Kind", schedule.TypeMeta.Kind, "Resource.Namespace", schedule.Namespace, "Resource.Name", schedule.Name)
			return newApplicationError(err, ErrClientK8s)
		}
		return nil
	case "tekton_extra_perm_rbac":
		// We only need one ClusterRoleBinding for a given project. Therefore the naming. It gets created by any of the sites in
		// the project if it doesn't exist. We don't delete it specifically as well, it can be handled with project deletion
		rbac := &rbacv1.ClusterRoleBinding{ObjectMeta: metav1.ObjectMeta{Name: "tektoncd-extra-permissions-" + d.Namespace}}
		_, err := controllerruntime.CreateOrUpdate(ctx, r.Client, rbac, func() error {
			return clusterRoleBindingForTektonExtraPermission(rbac, d)
		})
		if err != nil {
			log.Error(err, "Failed to ensure Resource", "Kind", rbac.TypeMeta.Kind, "Resource.Name", rbac.Name)
		}
		return nil
	case "gitlab_trigger_secret":
		// TODO: secret names must be short (I believe <64 chars), and given the maximum name length of a DrupalSite (50 chars), this is too long
		// In order to shorten this name we'll have to change the deployment to enforce the volumes.
		gitlab_trigger_secret := &corev1.Secret{ObjectMeta: metav1.ObjectMeta{Name: "gitlab-trigger-secret-" + d.Name, Namespace: d.Namespace}}
		_, err := controllerruntime.CreateOrUpdate(ctx, r.Client, gitlab_trigger_secret, func() error {
			log.V(4).Info("Ensuring Resource", "Kind", gitlab_trigger_secret.TypeMeta.Kind, "Resource.Namespace", gitlab_trigger_secret.Namespace, "Resource.Name", gitlab_trigger_secret.Name)
			return secretForS2iGitlabTrigger(gitlab_trigger_secret, d)
		})
		if err != nil {
			log.Error(err, "Failed to ensure Resource", "Kind", gitlab_trigger_secret.TypeMeta.Kind, "Resource.Namespace", gitlab_trigger_secret.Namespace, "Resource.Name", gitlab_trigger_secret.Name)
			return newApplicationError(err, ErrClientK8s)
		}
		return nil
	default:
		return newApplicationError(nil, ErrFunctionDomain)
	}
}

/*
ensureDrupalDeployment is similar to ensureResourceX, but for the Drupal server deployment, which requires extra information.
*/
func (r *DrupalSiteReconciler) ensureDrupalDeployment(ctx context.Context, d *webservicesv1a1.DrupalSite, config DeploymentConfig, log logr.Logger) (transientErr reconcileError) {
	deploy := &appsv1.Deployment{ObjectMeta: metav1.ObjectMeta{Name: d.Name, Namespace: d.Namespace}}
	err := r.Get(ctx, types.NamespacedName{Name: deploy.Name, Namespace: deploy.Namespace}, deploy)

	// Check if a deployment exists & if any of the given conditions satisfy
	// In scenarios where, the deployment is deleted during a failed upgrade, this check is needed to bring it back
	if err == nil && (d.ConditionTrue("CodeUpdateFailed") || d.ConditionTrue("DBUpdatesFailed")) {
		return nil
	}
	if databaseSecret := databaseSecretName(d); len(databaseSecret) != 0 {
		deploy := &appsv1.Deployment{ObjectMeta: metav1.ObjectMeta{Name: d.Name, Namespace: d.Namespace}}
		_, err = controllerruntime.CreateOrUpdate(ctx, r.Client, deploy, func() error {
			releaseID := releaseID(d)
			return deploymentForDrupalSite(deploy, databaseSecret, d, releaseID, config)
		})
		if err != nil {
			log.Error(err, "Failed to ensure Resource", "Kind", deploy.TypeMeta.Kind, "Resource.Namespace", deploy.Namespace, "Resource.Name", deploy.Name)
			return newApplicationError(err, ErrClientK8s)
		}
	}
	return nil
}

// ensureNoExtraRouteResource uses the current SiteURL resource as reference and deletes any extra route
func (r *DrupalSiteReconciler) ensureNoExtraRouteResource(ctx context.Context, d *webservicesv1a1.DrupalSite, label string, log logr.Logger) (transientErr reconcileError) {
	ls := labelsForDrupalSite(d.Name)
	ls["app"] = "drupal"
	ls["route"] = label
	existingRoutes := &routev1.RouteList{}
	routeLabels, err := metav1.LabelSelectorAsSelector(&metav1.LabelSelector{
		MatchLabels: ls,
	})
	if err != nil {
		return newApplicationError(err, ErrFunctionDomain)
	}
	options := client.ListOptions{
		Namespace:     d.Namespace,
		LabelSelector: routeLabels,
	}
	err = r.Client.List(context.TODO(), existingRoutes, &options)
	if err != nil {
		log.Error(err, "Couldn't query routes with the given labels")
		return newApplicationError(err, ErrClientK8s)
	}
	routeRequestList := d.Spec.SiteURL
	routesToRemove := []webservicesv1a1.Url{}
	for _, route := range existingRoutes.Items {
		flag := false
		for _, req := range routeRequestList {
			if label == "webdav" {
				req = "webdav-" + req
			}
			if string(req) == route.Spec.Host {
				flag = true
				continue
			}
		}
		if !flag {
			routesToRemove = append(routesToRemove, webservicesv1a1.Url(route.Spec.Host))
		}
	}
	for _, route := range routesToRemove {
		if transientErr := r.ensureNoRoute(ctx, d, string(route), log); transientErr != nil {
			return transientErr
		}
	}
	return nil
}

// ensureNoExtraOidcReturnUriResource uses the current SiteURL resource as reference and deletes any extra oidcReturnURI
func (r *DrupalSiteReconciler) ensureNoExtraOidcReturnUriResource(ctx context.Context, d *webservicesv1a1.DrupalSite, label string, log logr.Logger) (transientErr reconcileError) {
	ls := labelsForDrupalSite(d.Name)
	ls["app"] = "drupal"
	ls["oidcReturnURI"] = label
	existingOidcReturnUris := &authz.OidcReturnURIList{}
	oidcReturnUriLabels, err := metav1.LabelSelectorAsSelector(&metav1.LabelSelector{
		MatchLabels: ls,
	})
	if err != nil {
		return newApplicationError(err, ErrFunctionDomain)
	}
	options := client.ListOptions{
		Namespace:     d.Namespace,
		LabelSelector: oidcReturnUriLabels,
	}
	err = r.Client.List(context.TODO(), existingOidcReturnUris, &options)
	if err != nil {
		log.Error(err, "Couldn't query oidcReturnUris with the given labels")
		return newApplicationError(err, ErrClientK8s)
	}
	oidcReturnUriRequestList := d.Spec.SiteURL
	oidcReturnUrisToRemove := []string{}
	for _, route := range existingOidcReturnUris.Items {
		flag := false
		for _, req := range oidcReturnUriRequestList {
			url, err := url.Parse(route.Spec.RedirectURI)
			if err != nil {
				return newApplicationError(err, ErrFunctionDomain)
			}
			if string(req) == url.Host {
				flag = true
				continue
			}
		}
		if !flag {
			url, err := url.Parse(route.Spec.RedirectURI)
			if err != nil {
				return newApplicationError(err, ErrFunctionDomain)
			}
			oidcReturnUrisToRemove = append(oidcReturnUrisToRemove, url.Host)
		}
	}
	for _, oidcReturnURI := range oidcReturnUrisToRemove {
		if transientErr := r.ensureNoReturnURI(ctx, d, oidcReturnURI, log); transientErr != nil {
			return transientErr
		}
	}
	return nil
}

// ensureNoRoute ensures there is no route object for the drupalsite
func (r *DrupalSiteReconciler) ensureNoRoute(ctx context.Context, d *webservicesv1a1.DrupalSite, Url string, log logr.Logger) (transientErr reconcileError) {
	hash := md5.Sum([]byte(Url))
	route := &routev1.Route{ObjectMeta: metav1.ObjectMeta{Name: d.Name + "-" + hex.EncodeToString(hash[0:4]), Namespace: d.Namespace}}
	if err := r.Get(ctx, types.NamespacedName{Name: route.Name, Namespace: route.Namespace}, route); err != nil {
		switch {
		case k8sapierrors.IsNotFound(err):
			return nil
		default:
			return newApplicationError(err, ErrClientK8s)
		}
	}
	if err := r.Delete(ctx, route); err != nil {
		return newApplicationError(err, ErrClientK8s)
	}
	return nil
}

// ensureNoReturnURI ensures there is no OIDC Return URI object for the drupalsite
func (r *DrupalSiteReconciler) ensureNoReturnURI(ctx context.Context, d *webservicesv1a1.DrupalSite, Url string, log logr.Logger) (transientErr reconcileError) {
	hash := md5.Sum([]byte(Url))
	oidc_return_uri := &authz.OidcReturnURI{}
	if err := r.Get(ctx, types.NamespacedName{Name: d.Name + "-" + hex.EncodeToString(hash[0:4]), Namespace: d.Namespace}, oidc_return_uri); err != nil {
		switch {
		case k8sapierrors.IsNotFound(err):
			return nil
		default:
			return newApplicationError(err, ErrClientK8s)
		}
	}
	if err := r.Delete(ctx, oidc_return_uri); err != nil {
		return newApplicationError(err, ErrClientK8s)
	}
	return nil
}

// ensureNoBackupSchedule ensures there is no Schedule object for the drupalsite
func (r *DrupalSiteReconciler) ensureNoBackupSchedule(ctx context.Context, d *webservicesv1a1.DrupalSite, log logr.Logger) (transientErr reconcileError) {
	schedule := &velerov1.Schedule{}
	if err := r.Get(ctx, types.NamespacedName{Name: generateScheduleName(d.Namespace, d.Name), Namespace: VeleroNamespace}, schedule); err != nil {
		switch {
		case k8sapierrors.IsNotFound(err):
			return nil
		default:
			return newApplicationError(err, ErrClientK8s)
		}
	}
	if err := r.Delete(ctx, schedule); err != nil {
		return newApplicationError(err, ErrClientK8s)
	}
	return nil
}

// imageStreamForDrupalSiteBuilderS2I returns a ImageStream object for Drupal SiteBuilder S2I
func imageStreamForDrupalSiteBuilderS2I(currentobject *imagev1.ImageStream, d *webservicesv1a1.DrupalSite) error {
	addOwnerRefToObject(currentobject, asOwner(d))
	currentobject.Spec.LookupPolicy.Local = true
	if currentobject.Labels == nil {
		currentobject.Labels = map[string]string{}
	}
	ls := labelsForDrupalSite(d.Name)
	ls["app"] = "sitebuilder"
	for k, v := range ls {
		currentobject.Labels[k] = v
	}
	return nil
}

// buildConfigForDrupalSiteBuilderS2I returns a BuildConfig object for Drupal SiteBuilder S2I
func buildConfigForDrupalSiteBuilderS2I(currentobject *buildv1.BuildConfig, d *webservicesv1a1.DrupalSite) error {
	addOwnerRefToObject(currentobject, asOwner(d))
	if currentobject.CreationTimestamp.IsZero() {
		currentobject.Spec = buildv1.BuildConfigSpec{
			CommonSpec: buildv1.CommonSpec{
				Resources:                 BuildResources,
				CompletionDeadlineSeconds: pointer.Int64Ptr(1200),
				Source: buildv1.BuildSource{
					Git: &buildv1.GitBuildSource{
						Ref: d.Spec.Configuration.ExtraConfigurationRepository.Branch,
						URI: d.Spec.Configuration.ExtraConfigurationRepo,
					},
				},
				Strategy: buildv1.BuildStrategy{
					SourceStrategy: &buildv1.SourceBuildStrategy{
						From: corev1.ObjectReference{
							Kind: "DockerImage",
							Name: SiteBuilderImage + ":" + releaseID(d),
						},
					},
				},
				Output: buildv1.BuildOutput{
					To: &corev1.ObjectReference{
						Kind: "ImageStreamTag",
						Name: "sitebuilder-s2i-" + d.Name + ":" + releaseID(d),
					},
				},
			},
			Triggers: []buildv1.BuildTriggerPolicy{
				{
					Type: buildv1.ConfigChangeBuildTriggerType,
				},
				{
					Type: buildv1.GitLabWebHookBuildTriggerType,
					GitLabWebHook: &buildv1.WebHookTrigger{
						Secret: "gitlab-trigger-secret-" + d.Name,
					},
				},
			},
		}
	}
	if currentobject.Labels == nil {
		currentobject.Labels = map[string]string{}
	}
	ls := labelsForDrupalSite(d.Name)
	ls["app"] = "sitebuilder"
	for k, v := range ls {
		currentobject.Labels[k] = v
	}
	return nil
}

// dbodForDrupalSite returns a DBOD resource for the the Drupal Site
func dbodForDrupalSite(currentobject *dbodv1a1.Database, d *webservicesv1a1.DrupalSite) error {
	addOwnerRefToObject(currentobject, asOwner(d))
	if currentobject.CreationTimestamp.IsZero() {
		dbID := md5.Sum([]byte(d.Namespace + "-" + d.Name))
		currentobject.Spec = dbodv1a1.DatabaseSpec{
			DatabaseClass: string(d.Spec.Configuration.DatabaseClass),
			DbName:        hex.EncodeToString(dbID[1:10]),
			DbUser:        hex.EncodeToString(dbID[1:10]),
			ExtraLabels: map[string]string{
				"drupalSite": d.Name,
			},
		}
	}
	// Enforce only the drupalsite labels on the resource on every iteration
	if currentobject.Labels == nil {
		currentobject.Labels = map[string]string{}
	}
	ls := labelsForDrupalSite(d.Name)
	ls["app"] = "dbod"
	for k, v := range ls {
		currentobject.Labels[k] = v
	}
	return nil
}

// deploymentForDrupalSite defines the server runtime deployment of a DrupalSite
func deploymentForDrupalSite(currentobject *appsv1.Deployment, databaseSecret string, d *webservicesv1a1.DrupalSite, releaseID string, config DeploymentConfig) error {
	ls := labelsForDrupalSite(d.Name)
	if currentobject.Labels == nil {
		currentobject.Labels = map[string]string{}
	}
	ls["app"] = "drupal"
	for k, v := range ls {
		currentobject.Labels[k] = v
	}

	addOwnerRefToObject(currentobject, asOwner(d))
	if currentobject.Annotations == nil {
		currentobject.Annotations = map[string]string{}
	}
	currentobject.Annotations["alpha.image.policy.openshift.io/resolve-names"] = "*"

	if currentobject.CreationTimestamp.IsZero() {
		currentobject.Spec.Template.Spec.Containers = []corev1.Container{{Name: "nginx"}, {Name: "php-fpm"}, {Name: "php-fpm-exporter"}, {Name: "webdav"}, {Name: "cron"}, {Name: "drupal-logs"}}
	} else {
		containerExists("nginx", currentobject)
		containerExists("php-fpm", currentobject)
		containerExists("php-fpm-exporter", currentobject)
		containerExists("webdav", currentobject)
		containerExists("cron", currentobject)
		containerExists("drupal-logs", currentobject)
	}

	// Settings only on creation (not enforced)
	if currentobject.CreationTimestamp.IsZero() {
		currentobject.Spec.Template.ObjectMeta.Annotations = map[string]string{}
		currentobject.Spec.Selector = &metav1.LabelSelector{
			MatchLabels: ls,
		}
		currentobject.Spec.Template.ObjectMeta.Labels = ls

		if _, bool := d.Annotations["nodeSelectorLabel"]; bool {
			if _, bool = d.Annotations["nodeSelectorValue"]; bool {
				currentobject.Spec.Template.Spec.NodeSelector = map[string]string{
					d.Annotations["nodeSelectorLabel"]: d.Annotations["nodeSelectorValue"],
				}
			}
		}

		currentobject.Spec.Template.Spec.Volumes = []corev1.Volume{
			{
				Name: "drupal-directory-" + d.Name,
				VolumeSource: corev1.VolumeSource{
					PersistentVolumeClaim: &corev1.PersistentVolumeClaimVolumeSource{
						ClaimName: "pv-claim-" + d.Name,
					},
				}},
			{
				Name: "php-config-volume",
				VolumeSource: corev1.VolumeSource{
					ConfigMap: &corev1.ConfigMapVolumeSource{
						LocalObjectReference: corev1.LocalObjectReference{
							Name: "php-fpm-" + d.Name,
						},
					},
				},
			},
			{
				Name: "nginx-global-config",
				VolumeSource: corev1.VolumeSource{
					ConfigMap: &corev1.ConfigMapVolumeSource{
						LocalObjectReference: corev1.LocalObjectReference{
							Name: "nginx-global-" + d.Name,
						},
					},
				},
			},
			{
				Name: "site-settings-php",
				VolumeSource: corev1.VolumeSource{
					ConfigMap: &corev1.ConfigMapVolumeSource{
						LocalObjectReference: corev1.LocalObjectReference{
							Name: "site-settings-" + d.Name,
						},
					},
				},
			},
			{
				Name:         "empty-dir",
				VolumeSource: corev1.VolumeSource{EmptyDir: &corev1.EmptyDirVolumeSource{}},
			},
			{
				Name: "webdav-volume",
				VolumeSource: corev1.VolumeSource{
					Secret: &corev1.SecretVolumeSource{
						SecretName: "webdav-secret-" + d.Name,
						Items: []corev1.KeyToPath{
							// Unecessary but garantees no other secrets are mounted
							{
								Key:  "htdigest",
								Path: "htdigest",
							},
						},
					},
				},
			},
			{
				// Tmp Dir storage to address issue https://gitlab.cern.ch/webservices/webframeworks-planning/-/issues/600
				Name: "tmp-dir",
				VolumeSource: corev1.VolumeSource{
					EmptyDir: &corev1.EmptyDirVolumeSource{Medium: corev1.StorageMediumMemory},
				},
			},
			{
				Name: "php-cli-config-volume",
				VolumeSource: corev1.VolumeSource{
					ConfigMap: &corev1.ConfigMapVolumeSource{
						LocalObjectReference: corev1.LocalObjectReference{
							Name: "php-cli-config-" + d.Name,
						},
					},
				},
			},
		}

		// TODO: gradually migrate this code outside of the `CreationTimestamp.IsZero` check
		for i, container := range currentobject.Spec.Template.Spec.Containers {
			switch container.Name {
			case "nginx":
				// Set to always due to https://gitlab.cern.ch/drupal/paas/drupalsite-operator/-/issues/54
				currentobject.Spec.Template.Spec.Containers[i].ImagePullPolicy = "Always"
				currentobject.Spec.Template.Spec.Containers[i].Ports = []corev1.ContainerPort{{
					ContainerPort: 8080,
					Name:          "nginx",
					Protocol:      "TCP",
				}}
				currentobject.Spec.Template.Spec.Containers[i].Env = []corev1.EnvVar{
					{
						Name:  "DRUPAL_SHARED_VOLUME",
						Value: "/drupal-data",
					},
				}
				currentobject.Spec.Template.Spec.Containers[i].VolumeMounts = []corev1.VolumeMount{
					{
						Name:      "drupal-directory-" + d.Name,
						MountPath: "/drupal-data",
					},
					{
						Name:      "nginx-global-config",
						MountPath: "/etc/nginx/global.conf",
						SubPath:   "global.conf",
						ReadOnly:  true,
					},
					{
						Name:      "empty-dir",
						MountPath: "/var/run/",
					},
				}
				// TODO: add readiness probe. Tmp removed due to https://gitlab.cern.ch/webservices/webframeworks-planning/-/issues/542
			case "php-fpm":
				// Set to always due to https://gitlab.cern.ch/drupal/paas/drupalsite-operator/-/issues/54
				currentobject.Spec.Template.Spec.Containers[i].ImagePullPolicy = "Always"
				currentobject.Spec.Template.Spec.Containers[i].Ports = []corev1.ContainerPort{{
					ContainerPort: 9000,
					Name:          "php-fpm",
					Protocol:      "TCP",
				}}
				currentobject.Spec.Template.Spec.Containers[i].Env = []corev1.EnvVar{
					{
						Name:  "DRUPAL_SHARED_VOLUME",
						Value: "/drupal-data",
					},
					{
						Name:  "SMTPHOST",
						Value: SMTPHost,
					},
				}
				currentobject.Spec.Template.Spec.Containers[i].EnvFrom = []corev1.EnvFromSource{
					{
						SecretRef: &corev1.SecretEnvSource{
							LocalObjectReference: corev1.LocalObjectReference{
								Name: databaseSecret,
							},
						},
					},
					{
						SecretRef: &corev1.SecretEnvSource{
							LocalObjectReference: corev1.LocalObjectReference{
								Name: oidcSecretName, //This is always set the same way
							},
						},
					},
				}
				currentobject.Spec.Template.Spec.Containers[i].VolumeMounts = []corev1.VolumeMount{
					{
						Name:      "drupal-directory-" + d.Name,
						MountPath: "/drupal-data",
					},
					{
						Name:      "php-config-volume",
						MountPath: "/usr/local/etc/php-fpm.d/zz-docker.conf",
						SubPath:   "zz-docker.conf",
						ReadOnly:  true,
					},
					{
						Name:      "empty-dir",
						MountPath: "/var/run/",
					},
					{
						Name:      "site-settings-php",
						MountPath: "/app/web/sites/default/settings.php",
						SubPath:   "settings.php",
						ReadOnly:  true,
					},
					{
						// Tmp Dir storage to address issue https://gitlab.cern.ch/webservices/webframeworks-planning/-/issues/600
						Name:      "tmp-dir",
						MountPath: "/tmp",
					},
					{
						Name:      "php-cli-config-volume",
						MountPath: "/usr/local/etc/php/conf.d/config.ini",
						SubPath:   "config.ini",
						ReadOnly:  true,
					},
				}
			case "php-fpm-exporter":
				// Set to always due to https://gitlab.cern.ch/drupal/paas/drupalsite-operator/-/issues/54
				currentobject.Spec.Template.Spec.Containers[i].ImagePullPolicy = "Always"
				// Port on which to expose metrics
				currentobject.Spec.Template.Spec.Containers[i].Ports = []corev1.ContainerPort{{
					ContainerPort: 9253,
					Name:          "php-fpm-metrics",
					Protocol:      "TCP",
				}}
				currentobject.Spec.Template.Spec.Containers[i].Env = []corev1.EnvVar{
					{
						Name:  "PHP_FPM_SCRAPE_URI",
						Value: "unix:///var/run/drupal.sock;/_site/_php-fpm-status",
					},
				}
				currentobject.Spec.Template.Spec.Containers[i].VolumeMounts = []corev1.VolumeMount{
					{
						Name:      "empty-dir",
						MountPath: "/var/run/",
					},
				}
			case "webdav":
				// Set to always due to https://gitlab.cern.ch/drupal/paas/drupalsite-operator/-/issues/54
				currentobject.Spec.Template.Spec.Containers[i].ImagePullPolicy = "Always"
				currentobject.Spec.Template.Spec.Containers[i].Ports = []corev1.ContainerPort{{
					ContainerPort: 8008,
					Name:          "webdav",
					Protocol:      "TCP",
				}}
				//TODO: mount password as file
				currentobject.Spec.Template.Spec.Containers[i].Env = []corev1.EnvVar{
					{
						Name:  "DRUPAL_SHARED_VOLUME",
						Value: "/drupal-data",
					},
				}
				currentobject.Spec.Template.Spec.Containers[i].VolumeMounts = []corev1.VolumeMount{
					{
						Name:      "drupal-directory-" + d.Name,
						MountPath: "/drupal-data",
					},
					{
						Name:      "webdav-volume",
						MountPath: "/webdav/htdigest",
						ReadOnly:  true,
					},
					{
						Name:      "empty-dir",
						MountPath: "/var/run/",
					},
				}
			}
		}
	}

	// Skip enforcing values when debug annotation is present
	if len(currentobject.GetAnnotations()[debugAnnotation]) > 0 {
		// Do nothing
		return nil
	}

	// Settings on update
	// We should not enforce image field on every reconcile for containers that rely on imagestreams. For imagestream, the image value will be resolved from the tag name to SHA value by openshift. This in turn causes indefinite rollouts.
	_, annotExists := currentobject.Spec.Template.ObjectMeta.Annotations["releaseID"]
	if !annotExists || currentobject.Spec.Template.ObjectMeta.Annotations["releaseID"] != releaseID {
		for i, container := range currentobject.Spec.Template.Spec.Containers {
			switch container.Name {
			case "nginx":
				currentobject.Spec.Template.Spec.Containers[i].Image = sitebuilderImageRefToUse(d, releaseID).Name
			case "php-fpm":
				currentobject.Spec.Template.Spec.Containers[i].Image = sitebuilderImageRefToUse(d, releaseID).Name
			case "cron":
				currentobject.Spec.Template.Spec.Containers[i].Image = sitebuilderImageRefToUse(d, releaseID).Name
			case "drupal-logs":
				currentobject.Spec.Template.Spec.Containers[i].Image = sitebuilderImageRefToUse(d, releaseID).Name
			}
		}
	}

	// Settings enforced always
	for i, container := range currentobject.Spec.Template.Spec.Containers {
		switch container.Name {
		case "nginx":
			currentobject.Spec.Template.Spec.Containers[i].Command = []string{"/run-nginx.sh"}
			currentobject.Spec.Template.Spec.Containers[i].Resources = config.nginxResources
		case "php-fpm":
			currentobject.Spec.Template.Spec.Containers[i].Command = []string{"/run-php-fpm.sh"}
			currentobject.Spec.Template.Spec.Containers[i].Resources = config.phpResources
			currentobject.Spec.Template.Spec.Containers[i].LivenessProbe = &v1.Probe{
				Handler: v1.Handler{
					Exec: &v1.ExecAction{
						Command: customProbe("liveness"),
					},
				},
				InitialDelaySeconds: 1800, // Restarting soon after initialization can't fix anything
				TimeoutSeconds:      202,
				PeriodSeconds:       210,
				FailureThreshold:    5,
				SuccessThreshold:    1,
			}
			currentobject.Spec.Template.Spec.Containers[i].StartupProbe = &v1.Probe{
				Handler: v1.Handler{
					Exec: &v1.ExecAction{
						Command: startupProbe(),
					},
				},
				InitialDelaySeconds: 2, // fast check, since this is a startup probe
				TimeoutSeconds:      3,
				PeriodSeconds:       3,
				FailureThreshold:    3,
				SuccessThreshold:    1,
			}
		case "php-fpm-exporter":
			currentobject.Spec.Template.Spec.Containers[i].Image = PhpFpmExporterImage
			currentobject.Spec.Template.Spec.Containers[i].Resources = config.phpExporterResources
		case "webdav":
			currentobject.Spec.Template.Spec.Containers[i].Image = WebDAVImage
			currentobject.Spec.Template.Spec.Containers[i].Command = []string{"php-fpm"}
			currentobject.Spec.Template.Spec.Containers[i].Resources = config.webDAVResources
		case "cron":
			currentobject.Spec.Template.Spec.Containers[i].Command = []string{
				"sh",
				"-c",
				"/operations/cronjob.sh -s " + d.Name,
			}
			currentobject.Spec.Template.Spec.Containers[i].Resources = config.cronResources
			currentobject.Spec.Template.Spec.Containers[i].ImagePullPolicy = "Always"
			currentobject.Spec.Template.Spec.Containers[i].VolumeMounts = []corev1.VolumeMount{
				{
					Name:      "php-cli-config-volume",
					MountPath: "/usr/local/etc/php/conf.d/config.ini",
					SubPath:   "config.ini",
					ReadOnly:  true,
				},
				{
					Name:      "empty-dir",
					MountPath: "/var/run/",
				},
			}
		case "drupal-logs":
			currentobject.Spec.Template.Spec.Containers[i].Command = tailDrupalLogs()
			currentobject.Spec.Template.Spec.Containers[i].Resources = config.drupalLogsResources
			// Set to always due to https://gitlab.cern.ch/drupal/paas/drupalsite-operator/-/issues/54
			currentobject.Spec.Template.Spec.Containers[i].ImagePullPolicy = "Always"
			currentobject.Spec.Template.Spec.Containers[i].Ports = []corev1.ContainerPort{{
				ContainerPort: 8085,
				Name:          "drupal-logs",
				Protocol:      "TCP",
			}}
			currentobject.Spec.Template.Spec.Containers[i].VolumeMounts = []corev1.VolumeMount{
				{
					Name:      "empty-dir",
					MountPath: "/var/run/",
				},
			}
		}
	}
	currentobject.Spec.Replicas = &config.replicas
	// Add an annotation to be able to verify what releaseID of pod is running. Did not use labels, as it will affect the labelselector for the deployment and might cause downtime
	currentobject.Spec.Template.ObjectMeta.Annotations["releaseID"] = releaseID
	currentobject.Spec.Template.ObjectMeta.Annotations["pre.hook.backup.velero.io/container"] = "php-fpm"
	currentobject.Spec.Template.ObjectMeta.Annotations["pre.hook.backup.velero.io/command"] = "[\"sh\",\"-c\", \"/operations/database-backup.sh -f database_backup.sql\"]"
	// Since we have varying sizes of databases, the timeout needs to be large enough. Else the backups will fail.
	// Ref: https://gitlab.cern.ch/drupal/paas/drupalsite-operator/-/issues/71
	currentobject.Spec.Template.ObjectMeta.Annotations["pre.hook.backup.velero.io/timeout"] = "90m"
	currentobject.Spec.Template.ObjectMeta.Annotations["backup.velero.io/backup-volumes"] = "drupal-directory-" + d.Name
	if d.Spec.QoSClass == webservicesv1a1.QoSCritical {
		currentobject.Annotations["critical-site"] = "true"
		// TODO: move this to the `DeploymentConfig` function
		// openshift-user-critical is part of the default OKD4 Priority classes
		// https://github.com/openshift/cluster-config-operator/blob/168704868381c88551627239d132a3900eedc14f/manifests/0000_50_config-operator_09_user-priority-class.yaml
		currentobject.Spec.Template.Spec.PriorityClassName = "openshift-user-critical"
	}

	// Ensure availability zones for critical sites if enabled
	if d.Spec.QoSClass == webservicesv1a1.QoSCritical && EnableTopologySpread {
		currentobject.Spec.Template.Spec.TopologySpreadConstraints = []v1.TopologySpreadConstraint{
			{
				LabelSelector: &metav1.LabelSelector{
					MatchLabels: map[string]string{
						"drupalSite": d.Name,
					},
				},
				TopologyKey:       "topology.kubernetes.io/zone",
				MaxSkew:           1,
				WhenUnsatisfiable: v1.UnsatisfiableConstraintAction("DoNotSchedule"),
			},
		}
	} else {
		currentobject.Spec.Template.Spec.TopologySpreadConstraints = []v1.TopologySpreadConstraint{}
	}

	// Ensure S2I rollouts on image change
	if len(d.Spec.Configuration.ExtraConfigurationRepo) > 0 {
		// This annotation is required to trigger new rollout, when the imagestream gets updated with a new image for the given tag. Without this, deployments might start running with
		// a wrong image built from a different build, that is left out on the node
		currentobject.Annotations["image.openshift.io/triggers"] =
			"[{\"from\":{\"kind\":\"ImageStreamTag\",\"name\":\"sitebuilder-s2i-" + d.Name + ":" + releaseID + "\",\"namespace\":\"" + d.Namespace + "\"},\"fieldPath\":\"spec.template.spec.containers[?(@.name==\\\"nginx\\\")].image\",\"pause\":\"false\"},{\"from\":{\"kind\":\"ImageStreamTag\",\"name\":\"sitebuilder-s2i-" + d.Name + ":" + releaseID + "\",\"namespace\":\"" + d.Namespace + "\"},\"fieldPath\":\"spec.template.spec.containers[?(@.name==\\\"php-fpm\\\")].image\",\"pause\":\"false\"}]"
	}

	return nil
}

// secretForWebDAV returns a Secret object
func secretForWebDAV(currentobject *corev1.Secret, d *webservicesv1a1.DrupalSite) error {
	addOwnerRefToObject(currentobject, asOwner(d))
	currentobject.Type = "kubernetes.io/opaque"
	encryptedOpaquePassword := encryptBasicAuthPassword(d.Spec.Configuration.WebDAVPassword)
	currentobject.StringData = map[string]string{
		"htdigest": encryptedOpaquePassword,
	}
	if currentobject.Labels == nil {
		currentobject.Labels = map[string]string{}
	}
	ls := labelsForDrupalSite(d.Name)
	ls["app"] = "drupal"
	for k, v := range ls {
		currentobject.Labels[k] = v
	}
	return nil
}

// persistentVolumeClaimForDrupalSite returns a PVC object
func persistentVolumeClaimForDrupalSite(currentobject *corev1.PersistentVolumeClaim, d *webservicesv1a1.DrupalSite) error {
	addOwnerRefToObject(currentobject, asOwner(d))
	if currentobject.CreationTimestamp.IsZero() {
		currentobject.Spec = corev1.PersistentVolumeClaimSpec{
			// Selector: &metav1.LabelSelector{
			// 	MatchLabels: ls,
			// },
			StorageClassName: pointer.StringPtr("cephfs-no-backup"),
			AccessModes:      []corev1.PersistentVolumeAccessMode{"ReadWriteMany"},
		}
	}

	currentobject.Spec.Resources = corev1.ResourceRequirements{
		Requests: corev1.ResourceList{
			corev1.ResourceName(corev1.ResourceStorage): resource.MustParse(d.Spec.Configuration.DiskSize),
		},
	}

	if currentobject.Labels == nil {
		currentobject.Labels = map[string]string{}
	}
	ls := labelsForDrupalSite(d.Name)
	ls["app"] = "drupal"
	for k, v := range ls {
		currentobject.Labels[k] = v
	}
	return nil
}

// serviceForDrupalSite returns a service object
func serviceForDrupalSite(currentobject *corev1.Service, d *webservicesv1a1.DrupalSite) error {
	if currentobject.Labels == nil {
		currentobject.Labels = map[string]string{}
	}
	ls := labelsForDrupalSite(d.Name)
	ls["app"] = "drupal"
	for k, v := range ls {
		currentobject.Labels[k] = v
	}

	addOwnerRefToObject(currentobject, asOwner(d))
	currentobject.Spec.Selector = ls
	currentobject.Spec.Ports = []corev1.ServicePort{
		{
			TargetPort: intstr.FromInt(8080),
			Name:       "nginx",
			Port:       80,
			Protocol:   "TCP",
		},
		{
			TargetPort: intstr.FromInt(9253),
			Name:       "php-fpm-exporter",
			Port:       9253,
			Protocol:   "TCP",
		}}
	return nil
}

// routeForDrupalSite returns a route object
func routeForDrupalSite(currentobject *routev1.Route, d *webservicesv1a1.DrupalSite, Url string) error {
	addOwnerRefToObject(currentobject, asOwner(d))
	currentobject.Spec.TLS = &routev1.TLSConfig{
		InsecureEdgeTerminationPolicy: "Redirect",
		Termination:                   "edge",
	}
	currentobject.Spec.To = routev1.RouteTargetReference{
		Kind:   "Service",
		Name:   d.Name,
		Weight: pointer.Int32Ptr(100),
	}
	currentobject.Spec.Port = &routev1.RoutePort{
		TargetPort: intstr.FromInt(8080),
	}

	if currentobject.Annotations == nil {
		currentobject.Annotations = map[string]string{}
	}
	if currentobject.Labels == nil {
		currentobject.Labels = map[string]string{}
	}
	ls := labelsForDrupalSite(d.Name)
	ls["app"] = "drupal"
	// Adding a new label to be able to filter and remove extra resources when there are changes in Spec.SiteURL
	ls["route"] = "drupal"
	for k, v := range ls {
		currentobject.Labels[k] = v
	}

	if _, exists := d.Annotations["haproxy.router.openshift.io/ip_whitelist"]; exists {
		currentobject.Annotations["haproxy.router.openshift.io/ip_whitelist"] = d.Annotations["haproxy.router.openshift.io/ip_whitelist"]
	}
	// Set timeout to 60sec: https://gitlab.cern.ch/webservices/webframeworks-planning/-/issues/642
	currentobject.Annotations["haproxy.router.openshift.io/timeout"] = "200s"
	currentobject.Spec.Host = Url
	return nil
}

// newOidcReturnURI returns a oidcReturnURI object
func newOidcReturnURI(currentobject *authz.OidcReturnURI, d *webservicesv1a1.DrupalSite, Url string, http bool) error {
	returnURI := ""
	addOwnerRefToObject(currentobject, asOwner(d))
	url, err := url.Parse(Url)
	if err != nil {
		return err
	}

	if currentobject.Labels == nil {
		currentobject.Labels = map[string]string{}
	}
	ls := labelsForDrupalSite(d.Name)
	ls["app"] = "drupal"
	// Adding a new label to be able to filter and remove extra resources when there are changes in Spec.SiteURL
	ls["oidcReturnURI"] = "drupal"
	for k, v := range ls {
		currentobject.Labels[k] = v
	}

	// This will append `/openid-connect/*` to the URL, guaranteeing all subpaths of the link can be redirected
	url.Path = path.Join(url.Path, "openid-connect")
	if http {
		returnURI = "http://" + url.String() + "/*" // Hardcoded since with path.Join method creates `%2A` which will not work in the AuthzAPI, and the prefix `http`
	} else {
		returnURI = "https://" + url.String() + "/*" // Hardcoded since with path.Join method creates `%2A` which will not work in the AuthzAPI, and the prefix `http`
	}
	currentobject.Spec = authz.OidcReturnURISpec{
		RedirectURI: returnURI,
	}
	return nil
}

// jobForDrupalSiteInstallation returns a job object thats runs drush
func jobForDrupalSiteInstallation(currentobject *batchv1.Job, databaseSecret string, d *webservicesv1a1.DrupalSite) error {
	ls := labelsForDrupalSite(d.Name)
	if currentobject.CreationTimestamp.IsZero() {
		addOwnerRefToObject(currentobject, asOwner(d))
		currentobject.Labels = map[string]string{}
		currentobject.Spec.Template.ObjectMeta = metav1.ObjectMeta{
			Labels: ls,
		}
		currentobject.Spec.BackoffLimit = pointer.Int32Ptr(3)
		// Increasing the limit temporarily to fix https://gitlab.cern.ch/webservices/webframeworks-planning/-/issues/479
		currentobject.Spec.Template.Spec = corev1.PodSpec{
			InitContainers: []corev1.Container{{
				Image:           "bash",
				Name:            "pvc-init",
				ImagePullPolicy: "IfNotPresent",
				Command:         []string{"bash", "-c", "mkdir -p $DRUPAL_SHARED_VOLUME/{files,private,modules,themes}"},
				Env: []corev1.EnvVar{
					{
						Name:  "DRUPAL_SHARED_VOLUME",
						Value: "/drupal-data",
					},
				},
				VolumeMounts: []corev1.VolumeMount{{
					Name:      "drupal-directory-" + d.Name,
					MountPath: "/drupal-data",
				}},
			}},
			RestartPolicy: "Never",
			Containers: []corev1.Container{{
				Image:           sitebuilderImageRefToUse(d, releaseID(d)).Name,
				Name:            "drush",
				ImagePullPolicy: "Always",
				Resources: corev1.ResourceRequirements{
					Requests: corev1.ResourceList{
						corev1.ResourceMemory: resource.MustParse(jobMemoryRequest),
					},
				},
				Command: siteInstallJobForDrupalSite(),
				Env: []corev1.EnvVar{
					{
						Name:  "DRUPAL_SHARED_VOLUME",
						Value: "/drupal-data",
					},
					{
						Name:  "SMTPHOST",
						Value: SMTPHost,
					},
				},
				EnvFrom: []corev1.EnvFromSource{
					{
						SecretRef: &corev1.SecretEnvSource{
							LocalObjectReference: corev1.LocalObjectReference{
								Name: databaseSecret,
							},
						},
					},
					{
						SecretRef: &corev1.SecretEnvSource{
							LocalObjectReference: corev1.LocalObjectReference{
								Name: oidcSecretName, //This is always set the same way
							},
						},
					},
				},
				VolumeMounts: []corev1.VolumeMount{
					{
						Name:      "drupal-directory-" + d.Name,
						MountPath: "/drupal-data",
					},
					{
						Name:      "php-cli-config-volume",
						MountPath: "/usr/local/etc/php/conf.d/config.ini",
						SubPath:   "config.ini",
						ReadOnly:  true,
					},
					{
						Name:      "site-settings-php",
						MountPath: "/app/web/sites/default/settings.php",
						SubPath:   "settings.php",
						ReadOnly:  true,
					},
					{
						Name:      "empty-dir",
						MountPath: "/var/run/",
					},
				},
			}},
			Volumes: []corev1.Volume{
				{
					Name: "drupal-directory-" + d.Name,
					VolumeSource: corev1.VolumeSource{
						PersistentVolumeClaim: &corev1.PersistentVolumeClaimVolumeSource{
							ClaimName: "pv-claim-" + d.Name,
						},
					},
				},
				{
					Name: "site-settings-php",
					VolumeSource: corev1.VolumeSource{
						ConfigMap: &corev1.ConfigMapVolumeSource{
							LocalObjectReference: corev1.LocalObjectReference{
								Name: "site-settings-" + d.Name,
							},
						},
					},
				},
				{
					Name: "php-cli-config-volume",
					VolumeSource: corev1.VolumeSource{
						ConfigMap: &corev1.ConfigMapVolumeSource{
							LocalObjectReference: corev1.LocalObjectReference{
								Name: "php-cli-config-" + d.Name,
							},
						},
					},
				},
				{
					Name:         "empty-dir",
					VolumeSource: corev1.VolumeSource{EmptyDir: &corev1.EmptyDirVolumeSource{}},
				},
			},
		}
		ls["app"] = "drush"
		for k, v := range ls {
			currentobject.Labels[k] = v
		}
	}
	return nil
}

// jobForDrupalSiteClone returns a job object thats clones a drupalsite
func jobForDrupalSiteClone(currentobject *batchv1.Job, databaseSecret string, d *webservicesv1a1.DrupalSite) error {
	ls := labelsForDrupalSite(d.Name)
	// Temporary folder to store ephemeral files used during cloning procedure
	var emptyDir = "/var/empty-run/"
	if currentobject.CreationTimestamp.IsZero() {
		addOwnerRefToObject(currentobject, asOwner(d))
		currentobject.Labels = map[string]string{}
		currentobject.Spec.Template.ObjectMeta = metav1.ObjectMeta{
			Labels: ls,
		}
		currentobject.Spec.Template.Spec = corev1.PodSpec{
			InitContainers: []corev1.Container{
				{
					Image:           sitebuilderImageRefToUse(d, releaseID(d)).Name,
					Name:            "src-db-backup",
					ImagePullPolicy: "Always",
					Command:         takeBackup(emptyDir + "dbBackUp.sql"),
					Resources: corev1.ResourceRequirements{
						Requests: corev1.ResourceList{
							corev1.ResourceMemory: resource.MustParse(jobMemoryRequest),
						},
					},
					Env: []corev1.EnvVar{
						{
							Name:  "DRUPAL_SHARED_VOLUME",
							Value: "/drupal-data",
						},
					},
					EnvFrom: []corev1.EnvFromSource{
						{
							SecretRef: &corev1.SecretEnvSource{
								LocalObjectReference: corev1.LocalObjectReference{
									Name: "dbcredentials-" + string(d.Spec.Configuration.CloneFrom),
								},
							},
						},
					},

					VolumeMounts: []corev1.VolumeMount{
						{
							Name:      "tmp-dir",
							MountPath: emptyDir,
						},
					},
				},
			},
			RestartPolicy: "Never",
			Containers: []corev1.Container{{
				Image:           sitebuilderImageRefToUse(d, releaseID(d)).Name,
				Name:            "dest-clone",
				ImagePullPolicy: "Always",
				Command:         cloneSource(emptyDir + "dbBackUp.sql"),
				Env: []corev1.EnvVar{
					{
						Name:  "DRUPAL_SHARED_VOLUME",
						Value: "/drupal-data-source",
					},
				},
				EnvFrom: []corev1.EnvFromSource{
					{
						SecretRef: &corev1.SecretEnvSource{
							LocalObjectReference: corev1.LocalObjectReference{
								Name: databaseSecret,
							},
						},
					},
					{
						SecretRef: &corev1.SecretEnvSource{
							LocalObjectReference: corev1.LocalObjectReference{
								Name: oidcSecretName, //This is always set the same way
							},
						},
					},
				},
				VolumeMounts: []corev1.VolumeMount{
					{
						Name:      "drupal-directory-" + string(d.Spec.Configuration.CloneFrom),
						MountPath: "/drupal-data-source",
					},
					{
						Name:      "drupal-directory-" + d.Name,
						MountPath: "/drupal-data",
					},
					{
						Name:      "php-cli-config-volume",
						MountPath: "/usr/local/etc/php/conf.d/config.ini",
						SubPath:   "config.ini",
						ReadOnly:  true,
					},
					{
						Name:      "site-settings-php",
						MountPath: "/app/web/sites/default/settings.php",
						SubPath:   "settings.php",
						ReadOnly:  true,
					},
					{
						Name:      "tmp-dir",
						MountPath: emptyDir,
					},
				},
			}},
			Volumes: []corev1.Volume{
				{
					Name: "drupal-directory-" + d.Name,
					VolumeSource: corev1.VolumeSource{
						PersistentVolumeClaim: &corev1.PersistentVolumeClaimVolumeSource{
							ClaimName: "pv-claim-" + d.Name,
						},
					},
				},
				{
					Name: "drupal-directory-" + string(d.Spec.Configuration.CloneFrom),
					VolumeSource: corev1.VolumeSource{
						PersistentVolumeClaim: &corev1.PersistentVolumeClaimVolumeSource{
							ClaimName: "pv-claim-" + string(d.Spec.Configuration.CloneFrom),
						},
					},
				},
				{
					Name: "site-settings-php",
					VolumeSource: corev1.VolumeSource{
						ConfigMap: &corev1.ConfigMapVolumeSource{
							LocalObjectReference: corev1.LocalObjectReference{
								Name: "site-settings-" + d.Name,
							},
						},
					},
				},
				{
					Name: "php-cli-config-volume",
					VolumeSource: corev1.VolumeSource{
						ConfigMap: &corev1.ConfigMapVolumeSource{
							LocalObjectReference: corev1.LocalObjectReference{
								Name: "php-cli-config-" + d.Name,
							},
						},
					},
				},
				{
					// Tmp Dir storage to address issue https://gitlab.cern.ch/webservices/webframeworks-planning/-/issues/692
					Name:         "tmp-dir",
					VolumeSource: corev1.VolumeSource{EmptyDir: &corev1.EmptyDirVolumeSource{}},
				},
			},
		}
		ls["app"] = "clone"
		for k, v := range ls {
			currentobject.Labels[k] = v
		}
	}
	return nil
}

// taskRunForEasystartRestore returns a taskRun objects that restores easystart backup
func taskRunForEasystartRestore(currentobject *pipelinev1.TaskRun, d *webservicesv1a1.DrupalSite) error {
	if currentobject.CreationTimestamp.IsZero() {
		addOwnerRefToObject(currentobject, asOwner(d))
		currentobject.Spec = pipelinev1.TaskRunSpec{
			TaskRef: &pipelinev1.TaskRef{
				Name: "drupalsite-restore",
				Kind: "ClusterTask",
			},
			Params: []pipelinev1.Param{
				{
					Name:  "drupalSite",
					Value: pipelinev1.ArrayOrString{Type: pipelinev1.ParamTypeString, StringVal: d.Name},
				},
				{
					Name:  "backupName",
					Value: pipelinev1.ArrayOrString{Type: pipelinev1.ParamTypeString, StringVal: EasystartBackupName},
				},
				{
					Name:  "namespace",
					Value: pipelinev1.ArrayOrString{Type: pipelinev1.ParamTypeString, StringVal: d.Namespace},
				},
			},
			ServiceAccountName: "tektoncd",
		}
	}
	return nil
}

// scheduledBackupsForDrupalSite returns a velero Schedule object that creates scheduled backups
func scheduledBackupsForDrupalSite(currentobject *velerov1.Schedule, d *webservicesv1a1.DrupalSite) error {
	// Do not add owner references here. As this object is created in a different namespace. Instead the deletion
	// of this object is handled manually in the 'cleanupDrupalSite' function
	if currentobject.Annotations == nil {
		currentobject.Annotations = map[string]string{}
	}
	if currentobject.Labels == nil {
		currentobject.Labels = map[string]string{}
	}

	hash := md5.Sum([]byte(d.Namespace))
	currentobject.Labels["drupal.webservices.cern.ch/projectHash"] = hex.EncodeToString(hash[:])
	// Although labels don't suport more than 63 characters, according to https://gitlab.cern.ch/webservices/webframeworks-planning/-/issues/457 we should use annotations instead of labels.
	// But since we restrict drupalSite names and projects to less than 50chars, it should be ok to still have labels.
	// We still rely on annotations for fetching backups & reconciling Backup objects
	currentobject.Labels["drupal.webservices.cern.ch/project"] = d.Namespace
	currentobject.Labels["drupal.webservices.cern.ch/drupalSite"] = d.Name

	currentobject.Annotations["drupal.webservices.cern.ch/project"] = d.Namespace
	currentobject.Annotations["drupal.webservices.cern.ch/drupalSite"] = d.Name

	if currentobject.CreationTimestamp.IsZero() || len(currentobject.Spec.Schedule) == 0 {
		acceptedHoursForBackup := []string{"20", "21", "22", "23", "0", "1", "2", "3", "4", "5"}
		oddOrEven := []string{"1", "2"}
		randomHour := acceptedHoursForBackup[rand.Intn(len(acceptedHoursForBackup))]
		randomMinute := strconv.Itoa(rand.Intn(60))
		randomAlternateDay := oddOrEven[rand.Intn(len(oddOrEven))]
		currentobject.Spec.Schedule = randomMinute + " " + randomHour + " " + randomAlternateDay + "-31/2 * *"
	}

	currentobject.Spec.Template = velerov1.BackupSpec{
		IncludedNamespaces: []string{d.Namespace},
		IncludedResources:  []string{"pods"},
		// Add label selector to pick up the right pod and the respective PVC
		LabelSelector: &metav1.LabelSelector{
			MatchLabels: map[string]string{
				"app":        "drupal",
				"drupalSite": d.Name,
			},
		},
		// TTL is 14 days. The backups are deleted automatically after this duration
		TTL: metav1.Duration{
			Duration: 14 * 24 * time.Hour,
		},
	}
	// Set UseOwnerReferencesInBackup to False since we do not want the Backups to be deleted when Schedule object is deleted or modified
	currentobject.Spec.UseOwnerReferencesInBackup = pointer.BoolPtr(false)
	return nil
}

// clusterRoleBindingForTektonExtraPermission returns a ClusterRoleBinding object thats binds the tektoncd service account
// with the tektoncd-extra-permissions ClusterRole. This binding grants permissions to create jobs (and only that)
func clusterRoleBindingForTektonExtraPermission(currentobject *rbacv1.ClusterRoleBinding, d *webservicesv1a1.DrupalSite) error {
	currentobject.RoleRef = rbacv1.RoleRef{
		APIGroup: "rbac.authorization.k8s.io",
		Kind:     "ClusterRole",
		Name:     "tektoncd-extra-permissions",
	}

	currentobject.Subjects = []rbacv1.Subject{
		{
			Kind:      "ServiceAccount",
			Name:      "tektoncd",
			Namespace: d.Namespace,
		},
	}
	return nil
}

// secretForS2iGitlabTrigger returns a Secret object for openshift buildconfig gitlab trigger
func secretForS2iGitlabTrigger(currentobject *corev1.Secret, d *webservicesv1a1.DrupalSite) error {
	addOwnerRefToObject(currentobject, asOwner(d))
	currentobject.Type = "kubernetes.io/opaque"
	// All configurations that we do not want to enforce, we set here
	if currentobject.CreationTimestamp.IsZero() {
		encryptedOpaquePassword := generateRandomPassword()
		currentobject.StringData = map[string]string{
			"WebHookSecretKey": encryptedOpaquePassword,
		}
	}
	if currentobject.Labels == nil {
		currentobject.Labels = map[string]string{}
	}
	ls := labelsForDrupalSite(d.Name)
	ls["app"] = "drupal"
	for k, v := range ls {
		currentobject.Labels[k] = v
	}
	return nil
}

// updateConfigMapForPHPFPM modifies the configmap to include the php-fpm settings file,
// but only if it's freshly created
func updateConfigMapForPHPFPM(ctx context.Context, currentobject *corev1.ConfigMap, d *webservicesv1a1.DrupalSite, c client.Client) error {
	configPath := "/tmp/runtime-config/qos-" + string(d.Spec.Configuration.QoSClass) + "/php-fpm.conf"
	content, err := ioutil.ReadFile(configPath)
	if err != nil {
		return newApplicationError(fmt.Errorf("reading PHP-FPM configMap failed: %w", err), ErrFilesystemIO)
	}

	addOwnerRefToObject(currentobject, asOwner(d))

	// All configurations that we do not want to enforce, we set here
	if currentobject.CreationTimestamp.IsZero() {
		// Upstream PHP docker images use zz-docker.conf for configuration and this file gets loaded last (because of 'zz*') and overrides the default configuration loaded from www.conf
		currentobject.Data = map[string]string{
			"zz-docker.conf": string(content),
		}
	}
	if currentobject.Annotations == nil {
		currentobject.Annotations = map[string]string{}
	}
	if currentobject.Labels == nil {
		currentobject.Labels = map[string]string{}
	}
	ls := labelsForDrupalSite(d.Name)
	ls["app"] = "php"
	for k, v := range ls {
		currentobject.Labels[k] = v
	}
	return nil
}

// updateConfigMapForNginxGlobal modifies the configmap to include the Nginx settings file.
// If the file contents change, it rolls out a new deployment.
func updateConfigMapForNginxGlobal(ctx context.Context, currentobject *corev1.ConfigMap, d *webservicesv1a1.DrupalSite, c client.Client) error {
	configPath := "/tmp/runtime-config/qos-" + string(d.Spec.Configuration.QoSClass) + "/nginx-global.conf"
	content, err := ioutil.ReadFile(configPath)
	if err != nil {
		return newApplicationError(fmt.Errorf("reading Nginx configuration failed: %w", err), ErrFilesystemIO)
	}

	addOwnerRefToObject(currentobject, asOwner(d))

	// All configurations that we do not want to enforce, we set here
	if currentobject.CreationTimestamp.IsZero() {
		currentobject.Data = map[string]string{
			"global.conf": string(content),
		}
	}

	if currentobject.Annotations == nil {
		currentobject.Annotations = map[string]string{}
	}
	if currentobject.Labels == nil {
		currentobject.Labels = map[string]string{}
	}
	ls := labelsForDrupalSite(d.Name)
	ls["app"] = "nginx"
	for k, v := range ls {
		currentobject.Labels[k] = v
	}
	return nil
}

// updateConfigMapForSiteSettings modifies the configmap to include the file settings.php
func updateConfigMapForSiteSettings(ctx context.Context, currentobject *corev1.ConfigMap, d *webservicesv1a1.DrupalSite, c client.Client) error {
	configPath := "/tmp/runtime-config/sitebuilder/settings.php"
	content, err := ioutil.ReadFile(configPath)
	if err != nil {
		return newApplicationError(fmt.Errorf("reading settings.php failed: %w", err), ErrFilesystemIO)
	}

	addOwnerRefToObject(currentobject, asOwner(d))

	// All configurations that we do not want to enforce, we set here
	if currentobject.CreationTimestamp.IsZero() {
		currentobject.Data = map[string]string{
			"settings.php": string(content),
		}
	}

	if currentobject.Labels == nil {
		currentobject.Labels = map[string]string{}
	}
	if currentobject.Annotations == nil {
		currentobject.Annotations = map[string]string{}
	}
	ls := labelsForDrupalSite(d.Name)
	ls["app"] = "nginx"
	for k, v := range ls {
		currentobject.Labels[k] = v
	}
	return nil
}

// updateConfigMapForPHPCLI modifies the configmap to include the file config.ini for php CLI
func updateConfigMapForPHPCLI(ctx context.Context, currentobject *corev1.ConfigMap, d *webservicesv1a1.DrupalSite, c client.Client) error {
	configPath := "/tmp/runtime-config/sitebuilder/config.ini"
	content, err := ioutil.ReadFile(configPath)
	if err != nil {
		return newApplicationError(fmt.Errorf("reading config.ini failed: %w", err), ErrFilesystemIO)
	}

	addOwnerRefToObject(currentobject, asOwner(d))

	// All configurations that we do not want to enforce, we set here
	if currentobject.CreationTimestamp.IsZero() {
		currentobject.Data = map[string]string{
			"config.ini": string(content),
		}
	}

	if currentobject.Labels == nil {
		currentobject.Labels = map[string]string{}
	}
	if currentobject.Annotations == nil {
		currentobject.Annotations = map[string]string{}
	}
	ls := labelsForDrupalSite(d.Name)
	ls["app"] = "php"
	for k, v := range ls {
		currentobject.Labels[k] = v
	}
	return nil
}
