/*
Copyright 2021 CERN.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
	"context"
	"crypto/md5"
	"encoding/hex"
	"fmt"
	"io"
	"io/ioutil"
	"math/rand"
	"net/url"
	"path"
	"reflect"
	"sort"
	"strconv"
	"time"

	"github.com/go-logr/logr"
	buildv1 "github.com/openshift/api/build/v1"
	imagev1 "github.com/openshift/api/image/v1"
	routev1 "github.com/openshift/api/route/v1"

	dbodv1a1 "gitlab.cern.ch/drupal/paas/dbod-operator/api/v1alpha1"
	webservicesv1a1 "gitlab.cern.ch/drupal/paas/drupalsite-operator/api/v1alpha1"
	authz "gitlab.cern.ch/paas-tools/operators/authz-operator/api/v1alpha1"
	appsv1 "k8s.io/api/apps/v1"
	batchv1 "k8s.io/api/batch/v1"
	batchbeta1 "k8s.io/api/batch/v1beta1"
	corev1 "k8s.io/api/core/v1"
	v1 "k8s.io/api/core/v1"
	rbacv1 "k8s.io/api/rbac/v1"
	k8sapierrors "k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/util/intstr"
	"k8s.io/utils/pointer"
	controllerruntime "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"

	velerov1 "github.com/vmware-tanzu/velero/pkg/apis/velero/v1"
)

// Const vars
const (
	// Variable used to define Default WebDAV login Username
	webDAVDefaultLogin string = "admin"
	// Variable to set the used Memory for all Jobs generated by the Operator
	jobMemoryRequest string = "256Mi"
)

var (
	// BuildResources are the resource requests/limits for the image builds. Set during initEnv()
	BuildResources corev1.ResourceRequirements
)

// execToServerPod executes a command to the first running server pod of the Drupal site.
//
// Commands are interpreted similar to how kubectl does it, eg to do "drush cr" either of these will work:
// - "drush", "cr"
// - "sh", "-c", "drush cr"
// The last syntax allows passing an entire bash script as a string.
//
// Example:
// ````
//	sout, serr, err := r.execToServerPod(ctx, drp, "php-fpm", nil, "sh", "-c", "drush version; ls")
//	sout, serr, err := r.execToServerPod(ctx, drp, "php-fpm", nil, "drush", "version")
//	if err != nil {
//		log.Error(err, "Error while exec into pod")
//	}
//	log.Info("EXEC", "stdout", sout, "stderr", serr)
// ````
func (r *DrupalSiteReconciler) execToServerPod(ctx context.Context, d *webservicesv1a1.DrupalSite, containerName string, stdin io.Reader, command ...string) (stdout string, stderr string, err error) {
	pod, err := r.getRunningPodForVersion(ctx, d, releaseID(d))
	if err != nil {
		return "", "", err
	}
	return execToPodThroughAPI(containerName, pod.Name, d.Namespace, stdin, command...)
}

// getRunningPodForVersion fetches the list of the running pods for the current deployment and returns the first one from the list
func (r *DrupalSiteReconciler) getRunningPodForVersion(ctx context.Context, d *webservicesv1a1.DrupalSite, releaseID string) (corev1.Pod, reconcileError) {
	podList := corev1.PodList{}
	podLabels, err := metav1.LabelSelectorAsSelector(&metav1.LabelSelector{
		MatchLabels: map[string]string{"drupalSite": d.Name, "app": "drupal"},
	})
	if err != nil {
		return corev1.Pod{}, newApplicationError(err, ErrFunctionDomain)
	}
	options := client.ListOptions{
		LabelSelector: podLabels,
		Namespace:     d.Namespace,
	}
	err = r.List(ctx, &podList, &options)
	switch {
	case err != nil:
		return corev1.Pod{}, newApplicationError(err, ErrClientK8s)
	case len(podList.Items) == 0:
		return corev1.Pod{}, newApplicationError(fmt.Errorf("No pod found with given labels: %s", podLabels), ErrTemporary)
	}
	for _, v := range podList.Items {
		if v.Annotations["releaseID"] == releaseID {
			if v.Status.Phase == corev1.PodRunning {
				return v, nil
			} else {
				return v, newApplicationError(err, ErrPodNotRunning)
			}
		}
	}
	// iterate through the list and return the first pod that has the status condition ready
	return corev1.Pod{}, newApplicationError(err, ErrClientK8s)
}

// execToServerPodErrOnStder works like `execToServerPod`, but puts the contents of stderr in the error, if not empty
func (r *DrupalSiteReconciler) execToServerPodErrOnStderr(ctx context.Context, d *webservicesv1a1.DrupalSite, containerName string, stdin io.Reader, command ...string) (stdout string, err error) {
	stdout, stderr, err := r.execToServerPod(ctx, d, containerName, stdin, command...)
	if err != nil || stderr != "" {
		return "", fmt.Errorf("STDERR: %s \n%w", stderr, err)
	}
	return stdout, nil
}

func (r *DrupalSiteReconciler) getDeployConfigmap(ctx context.Context, d *webservicesv1a1.DrupalSite) (deploy appsv1.Deployment,
	cmPhp corev1.ConfigMap, cmNginx corev1.ConfigMap, cmSettings corev1.ConfigMap, cmPhpCli corev1.ConfigMap, err error) {
	err = r.Get(ctx, types.NamespacedName{Name: d.Name, Namespace: d.Namespace}, &deploy)
	if err != nil {
		return
	}
	err = r.Get(ctx, types.NamespacedName{Name: "php-fpm-" + d.Name, Namespace: d.Namespace}, &cmPhp)
	if err != nil {
		return
	}
	err = r.Get(ctx, types.NamespacedName{Name: "nginx-" + d.Name, Namespace: d.Namespace}, &cmNginx)
	if err != nil {
		return
	}
	err = r.Get(ctx, types.NamespacedName{Name: "site-settings-" + d.Name, Namespace: d.Namespace}, &cmSettings)
	if err != nil {
		return
	}
	err = r.Get(ctx, types.NamespacedName{Name: "php-cli-config-" + d.Name, Namespace: d.Namespace}, &cmSettings)
	return
}

// ensureDeploymentConfigmapHash ensures that the deployment has annotations with the content of each configmap.
// If the content of the configmaps changes, this will ensure that the deployemnt rolls out.
func (r *DrupalSiteReconciler) ensureDeploymentConfigmapHash(ctx context.Context, d *webservicesv1a1.DrupalSite, log logr.Logger) (requeue bool, transientErr reconcileError) {
	deploy, cmPhp, cmNginx, cmSettings, cmPhpCli, err := r.getDeployConfigmap(ctx, d)
	switch {
	case k8sapierrors.IsNotFound(err):
		return false, nil
	case err != nil:
		return false, newApplicationError(err, ErrClientK8s)
	}
	updateDeploymentAnnotations := func(deploy *appsv1.Deployment, d *webservicesv1a1.DrupalSite) error {
		hashPhp := md5.Sum([]byte(createKeyValuePairs(cmPhp.Data)))
		hashNginx := md5.Sum([]byte(createKeyValuePairs(cmNginx.Data)))
		hashSettings := md5.Sum([]byte(createKeyValuePairs(cmSettings.Data)))
		hashPhpCli := md5.Sum([]byte(createKeyValuePairs(cmPhpCli.Data)))

		deploy.Spec.Template.ObjectMeta.Annotations["phpfpm-configmap/hash"] = hex.EncodeToString(hashPhp[:])
		deploy.Spec.Template.ObjectMeta.Annotations["nginx-configmap/hash"] = hex.EncodeToString(hashNginx[:])
		deploy.Spec.Template.ObjectMeta.Annotations["settings.php-configmap/hash"] = hex.EncodeToString(hashSettings[:])
		deploy.Spec.Template.ObjectMeta.Annotations["php-cli-configmap/hash"] = hex.EncodeToString(hashPhpCli[:])
		return nil
	}
	_, err = controllerruntime.CreateOrUpdate(ctx, r.Client, &deploy, func() error {
		return updateDeploymentAnnotations(&deploy, d)
	})
	switch {
	case k8sapierrors.IsConflict(err):
		log.V(4).Info("Server deployment changed while reconciling. Requeuing.")
		return true, nil
	case err != nil:
		return false, newApplicationError(fmt.Errorf("failed to annotate deployment with configmap hashes: %w", err), ErrClientK8s)
	}
	return false, nil
}

/*
ensureResources ensures the presence of all the resources that the DrupalSite needs to serve content.
This includes BuildConfigs/ImageStreams, DB, PVC, PHP/Nginx deployment + service, site install job, Routes.
*/
func (r *DrupalSiteReconciler) ensureResources(drp *webservicesv1a1.DrupalSite, deploymentConfig DeploymentConfig, log logr.Logger) (transientErrs []reconcileError) {
	ctx := context.TODO()

	// 1. BuildConfigs and ImageStreams

	if len(drp.Spec.Configuration.ExtraConfigurationRepo) > 0 {
		if transientErr := r.ensureResourceX(ctx, drp, "is_s2i", log); transientErr != nil {
			transientErrs = append(transientErrs, transientErr.Wrap("%v: for S2I SiteBuilder ImageStream"))
		}
		if transientErr := r.ensureResourceX(ctx, drp, "bc_s2i", log); transientErr != nil {
			transientErrs = append(transientErrs, transientErr.Wrap("%v: for S2I SiteBuilder BuildConfig"))
		}
		if transientErr := r.ensureResourceX(ctx, drp, "gitlab_trigger_secret", log); transientErr != nil {
			transientErrs = append(transientErrs, transientErr.Wrap("%v: for S2I SiteBuilder Secret"))
		}
	}
	// 2. Data layer

	if transientErr := r.ensureResourceX(ctx, drp, "pvc_drupal", log); transientErr != nil {
		transientErrs = append(transientErrs, transientErr.Wrap("%v: for Drupal PVC"))
	}
	if transientErr := r.ensureResourceX(ctx, drp, "dbod_cr", log); transientErr != nil {
		transientErrs = append(transientErrs, transientErr.Wrap("%v: for DBOD resource"))
	}
	if transientErr := r.ensureResourceX(ctx, drp, "webdav_secret", log); transientErr != nil {
		transientErrs = append(transientErrs, transientErr.Wrap("%v: for WebDAV Secret"))
	}

	// 3. Serving layer

	if transientErr := r.ensureResourceX(ctx, drp, "cm_php", log); transientErr != nil {
		transientErrs = append(transientErrs, transientErr.Wrap("%v: for PHP-FPM CM"))
	}
	if transientErr := r.ensureResourceX(ctx, drp, "cm_nginx", log); transientErr != nil {
		transientErrs = append(transientErrs, transientErr.Wrap("%v: for Nginx CM"))
	}
	if transientErr := r.ensureResourceX(ctx, drp, "cm_settings", log); transientErr != nil {
		transientErrs = append(transientErrs, transientErr.Wrap("%v: for settings.php CM"))
	}
	if transientErr := r.ensureResourceX(ctx, drp, "cm_php_cli", log); transientErr != nil {
		transientErrs = append(transientErrs, transientErr.Wrap("%v: for PHP Job CM"))
	}
	if r.isDBODProvisioned(ctx, drp) {
		if transientErr := r.ensureDrupalDeployment(ctx, drp, deploymentConfig, log); transientErr != nil {
			transientErrs = append(transientErrs, transientErr.Wrap("%v: for Drupal deployment"))
		}
	}
	if transientErr := r.ensureResourceX(ctx, drp, "svc_nginx", log); transientErr != nil {
		transientErrs = append(transientErrs, transientErr.Wrap("%v: for Nginx SVC"))
	}
	if r.isDBODProvisioned(ctx, drp) {
		if drp.Spec.Configuration.CloneFrom == "" {
			if transientErr := r.ensureResourceX(ctx, drp, "site_install_job", log); transientErr != nil {
				transientErrs = append(transientErrs, transientErr.Wrap("%v: for site install Job"))
			}
		} else {
			if transientErr := r.ensureResourceX(ctx, drp, "clone_job", log); transientErr != nil {
				transientErrs = append(transientErrs, transientErr.Wrap("%v: for clone Job"))
			}
		}
	}
	if drp.ConditionTrue("Initialized") {
		if transientErr := r.ensureResourceX(ctx, drp, "cronjob_crontask", log); transientErr != nil {
			transientErrs = append(transientErrs, transientErr.Wrap("%v: for Drupal Cronjob"))
		}
	}

	// 4. Ingress

	if drp.ConditionTrue("Initialized") {
		// each function below ensures 1 route per entry in `spec.siteUrl[]`. This is understandably part of the job of "ensuring resource X".
		if transientErr := r.ensureResourceX(ctx, drp, "route", log); transientErr != nil {
			transientErrs = append(transientErrs, transientErr.Wrap("%v: for Route"))
		}
		if transientErr := r.ensureResourceX(ctx, drp, "oidc_return_uri", log); transientErr != nil {
			transientErrs = append(transientErrs, transientErr.Wrap("%v: for OidcReturnURI"))
		}

		// each function below removes any unwanted routes
		if transientErr := r.ensureNoExtraRouteResource(ctx, drp, "drupal", log); transientErr != nil {
			transientErrs = append(transientErrs, transientErr.Wrap("%v: while ensuring no extra routes"))
		}
		if transientErr := r.ensureNoExtraOidcReturnUriResource(ctx, drp, "drupal", log); transientErr != nil {
			transientErrs = append(transientErrs, transientErr.Wrap("%v: while ensuring no extra OidcReturnURIs"))
		}
	} else {
		for _, url := range drp.Spec.SiteURL {
			if transientErr := r.ensureNoRoute(ctx, drp, string(url), log); transientErr != nil {
				transientErrs = append(transientErrs, transientErr.Wrap("%v: while deleting the Route"))
			}
			if transientErr := r.ensureNoReturnURI(ctx, drp, string(url), log); transientErr != nil {
				transientErrs = append(transientErrs, transientErr.Wrap("%v: while deleting the OidcReturnURI"))
			}
		}
	}

	// 5. Cluster-scoped: Backup schedule, Tekton RBAC

	if transientErr := r.ensureResourceX(ctx, drp, "backup_schedule", log); transientErr != nil {
		transientErrs = append(transientErrs, transientErr.Wrap("%v: for Velero Schedule"))
	}
	if transientErr := r.ensureResourceX(ctx, drp, "tekton_extra_perm_rbac", log); transientErr != nil {
		transientErrs = append(transientErrs, transientErr.Wrap("%v: for Tekton Extra Permissions ClusterRoleBinding"))
	}

	// 6. Redis cache for critical QoS Class sites

	if drp.Spec.QoSClass == webservicesv1a1.QoSCritical {
		if transientErr := r.ensureRedisDeployment(ctx, drp, deploymentConfig, log); transientErr != nil {
			transientErrs = append(transientErrs, transientErr.Wrap("%v: for Redis deployment"))
		}
		if transientErr := r.ensureResourceX(ctx, drp, "svc_redis", log); transientErr != nil {
			transientErrs = append(transientErrs, transientErr.Wrap("%v: for Redis service"))
		}
		if transientErr := r.ensureResourceX(ctx, drp, "secret_redis", log); transientErr != nil {
			transientErrs = append(transientErrs, transientErr.Wrap("%v: for Redis secret"))
		}
	} else {
		if transientErr := r.ensureNoRedisDeployment(ctx, drp, log); transientErr != nil {
			transientErrs = append(transientErrs, transientErr.Wrap("%v: while deleting the redis deployment"))
		}
		if transientErr := r.ensureNoRedisService(ctx, drp, log); transientErr != nil {
			transientErrs = append(transientErrs, transientErr.Wrap("%v: while deleting the redis service"))
		}
		if transientErr := r.ensureNoRedisSecret(ctx, drp, log); transientErr != nil {
			transientErrs = append(transientErrs, transientErr.Wrap("%v: while deleting the redis secret"))
		}
	}
	return transientErrs
}

/*
ensureResourceX ensure the requested resource is created, with the following valid values
	- pvc_drupal: PersistentVolume for the drupalsite
	- site_install_job: Kubernetes Job for the drush ensure-site-install
	- clone_job: Kubernetes Job for cloning a drupal site
	- is_base: ImageStream for sitebuilder-base
	- is_s2i: ImageStream for S2I sitebuilder
	- bc_s2i: BuildConfig for S2I sitebuilder
	- deploy_drupal: <moved to `ensureDrupalDeployment`>
	- svc_nginx: Service for Nginx
	- cm_php: ConfigMap for PHP-FPM
	- cm_nginx: ConfigMap for Nginx
	- cm_settings: ConfigMap for `settings.php`
	- cm_php_cli: ConfigMap for 'config.ini' for PHP CLI
	- route: Route for the drupalsite
	- oidc_return_uri: Redirection URI for OIDC
	- dbod_cr: DBOD custom resource to establish database & respective connection for the drupalsite
	- webdav_secret: Secret with credential for WebDAV
	- backup_schedule: Velero Schedule for scheduled backups of the drupalSite
	- tekton_extra_perm_rbac: ClusterRoleBinding for tekton tasks
	- cronjob: Creates cronjob to trigger Cron tasks on Drupalsites, see: https://gitlab.cern.ch/webservices/webframeworks-planning/-/issues/437
	- svc_redis: Redis Service for a critical QoS site
	- gitlab_trigger_secret: Secret for Gitlab trigger config in buildconfig
*/
func (r *DrupalSiteReconciler) ensureResourceX(ctx context.Context, d *webservicesv1a1.DrupalSite, resType string, log logr.Logger) (transientErr reconcileError) {
	switch resType {
	case "is_s2i":
		is := &imagev1.ImageStream{ObjectMeta: metav1.ObjectMeta{Name: "sitebuilder-s2i-" + d.Name, Namespace: d.Namespace}}
		_, err := controllerruntime.CreateOrUpdate(ctx, r.Client, is, func() error {
			return imageStreamForDrupalSiteBuilderS2I(is, d)
		})
		if err != nil {
			log.Error(err, "Failed to ensure Resource", "Kind", is.TypeMeta.Kind, "Resource.Namespace", is.Namespace, "Resource.Name", is.Name)
			return newApplicationError(err, ErrClientK8s)
		}
		return nil
	case "bc_s2i":
		bc := &buildv1.BuildConfig{ObjectMeta: metav1.ObjectMeta{Name: "sitebuilder-s2i-" + nameVersionHash(d), Namespace: d.Namespace}}
		// We don't really benefit from udating here, because of https://docs.openshift.com/container-platform/4.6/builds/triggering-builds-build-hooks.html#builds-configuration-change-triggers_triggering-builds-build-hooks
		_, err := controllerruntime.CreateOrUpdate(ctx, r.Client, bc, func() error {
			return buildConfigForDrupalSiteBuilderS2I(bc, d)
		})
		if err != nil {
			log.Error(err, "Failed to ensure Resource", "Kind", bc.TypeMeta.Kind, "Resource.Namespace", bc.Namespace, "Resource.Name", bc.Name)
			return newApplicationError(err, ErrClientK8s)
		}
		return nil
	case "webdav_secret":
		webdav_secret := &corev1.Secret{ObjectMeta: metav1.ObjectMeta{Name: "webdav-secret-" + d.Name, Namespace: d.Namespace}}
		_, err := controllerruntime.CreateOrUpdate(ctx, r.Client, webdav_secret, func() error {
			log.V(3).Info("Ensuring Resource", "Kind", webdav_secret.TypeMeta.Kind, "Resource.Namespace", webdav_secret.Namespace, "Resource.Name", webdav_secret.Name)
			return secretForWebDAV(webdav_secret, d)
		})
		if err != nil {
			log.Error(err, "Failed to ensure Resource", "Kind", webdav_secret.TypeMeta.Kind, "Resource.Namespace", webdav_secret.Namespace, "Resource.Name", webdav_secret.Name)
			return newApplicationError(err, ErrClientK8s)
		}
		return nil
	case "svc_nginx":
		svc := &corev1.Service{ObjectMeta: metav1.ObjectMeta{Name: d.Name, Namespace: d.Namespace}}
		_, err := controllerruntime.CreateOrUpdate(ctx, r.Client, svc, func() error {
			return serviceForDrupalSite(svc, d)
		})
		if err != nil {
			log.Error(err, "Failed to ensure Resource", "Kind", svc.TypeMeta.Kind, "Resource.Namespace", svc.Namespace, "Resource.Name", svc.Name)
			return newApplicationError(err, ErrClientK8s)
		}
		return nil
	case "pvc_drupal":
		pvc := &corev1.PersistentVolumeClaim{ObjectMeta: metav1.ObjectMeta{Name: "pv-claim-" + d.Name, Namespace: d.Namespace}}
		_, err := controllerruntime.CreateOrUpdate(ctx, r.Client, pvc, func() error {
			return persistentVolumeClaimForDrupalSite(pvc, d)
		})
		if err != nil {
			log.Error(err, "Failed to ensure Resource", "Kind", pvc.TypeMeta.Kind, "Resource.Namespace", pvc.Namespace, "Resource.Name", pvc.Name)
			return newApplicationError(err, ErrClientK8s)
		}
		return nil
	case "route":
		routeRequestList := d.Spec.SiteURL
		for _, req := range routeRequestList {
			hash := md5.Sum([]byte(req))
			route := &routev1.Route{ObjectMeta: metav1.ObjectMeta{Name: d.Name + "-" + hex.EncodeToString(hash[0:4]), Namespace: d.Namespace}}
			_, err := controllerruntime.CreateOrUpdate(ctx, r.Client, route, func() error {
				return routeForDrupalSite(route, d, string(req))
			})
			// TODO: don't throw on conflict
			if err != nil {
				log.Error(err, "Failed to ensure Resource", "Kind", route.TypeMeta.Kind, "Resource.Namespace", route.Namespace, "Resource.Name", route.Name)
				return newApplicationError(err, ErrClientK8s)
			}
		}
		return nil
	case "oidc_return_uri":
		routeRequestList := d.Spec.SiteURL
		for _, req := range routeRequestList {
			hash := md5.Sum([]byte(req))
			OidcReturnURI := &authz.OidcReturnURI{ObjectMeta: metav1.ObjectMeta{Name: d.Name + "-" + hex.EncodeToString(hash[0:4]), Namespace: d.Namespace}}
			_, err := controllerruntime.CreateOrUpdate(ctx, r.Client, OidcReturnURI, func() error {
				log.V(3).Info("Ensuring Resource", "Kind", OidcReturnURI.TypeMeta.Kind, "Resource.Namespace", OidcReturnURI.Namespace, "Resource.Name", OidcReturnURI.Name)
				return newOidcReturnURI(OidcReturnURI, d, string(req))
			})
			if err != nil {
				log.Error(err, "Failed to ensure Resource", "Kind", OidcReturnURI.TypeMeta.Kind, "Resource.Namespace", OidcReturnURI.Namespace, "Resource.Name", OidcReturnURI.Name)
			}
		}
		return nil
	case "site_install_job":
		databaseSecretName := databaseSecretName(d)
		if len(databaseSecretName) == 0 {
			return nil
		}
		job := &batchv1.Job{ObjectMeta: metav1.ObjectMeta{Name: "ensure-site-install-" + d.Name, Namespace: d.Namespace}}
		_, err := controllerruntime.CreateOrUpdate(ctx, r.Client, job, func() error {
			return jobForDrupalSiteInstallation(job, databaseSecretName, d)
		})
		if err != nil {
			log.Error(err, "Failed to ensure Resource", "Kind", job.TypeMeta.Kind, "Resource.Namespace", job.Namespace, "Resource.Name", job.Name)
			return newApplicationError(err, ErrClientK8s)
		}
		return nil
	case "clone_job":
		if databaseSecret := databaseSecretName(d); len(databaseSecret) != 0 {
			job := &batchv1.Job{ObjectMeta: metav1.ObjectMeta{Name: "clone-" + d.Name, Namespace: d.Namespace}}
			_, err := controllerruntime.CreateOrUpdate(ctx, r.Client, job, func() error {
				log.V(3).Info("Ensuring Resource", "Kind", job.TypeMeta.Kind, "Resource.Namespace", job.Namespace, "Resource.Name", job.Name)
				return jobForDrupalSiteClone(job, databaseSecret, d)
			})
			if err != nil {
				log.Error(err, "Failed to ensure Resource", "Kind", job.TypeMeta.Kind, "Resource.Namespace", job.Namespace, "Resource.Name", job.Name)
				return newApplicationError(err, ErrClientK8s)
			}
		}
		return nil
	case "cm_php":
		cm := &corev1.ConfigMap{ObjectMeta: metav1.ObjectMeta{Name: "php-fpm-" + d.Name, Namespace: d.Namespace}}
		_, err := controllerruntime.CreateOrUpdate(ctx, r.Client, cm, func() error {
			return updateConfigMapForPHPFPM(ctx, cm, d, r.Client)
		})
		if err != nil {
			log.Error(err, "Failed to ensure Resource", "Kind", cm.TypeMeta.Kind, "Resource.Namespace", cm.Namespace, "Resource.Name", cm.Name)
			return newApplicationError(err, ErrClientK8s)
		}
		return nil
	case "cm_nginx":
		cm := &corev1.ConfigMap{ObjectMeta: metav1.ObjectMeta{Name: "nginx-" + d.Name, Namespace: d.Namespace}}
		_, err := controllerruntime.CreateOrUpdate(ctx, r.Client, cm, func() error {
			return updateConfigMapForNginx(ctx, cm, d, r.Client)
		})
		if err != nil {
			log.Error(err, "Failed to ensure Resource", "Kind", cm.TypeMeta.Kind, "Resource.Namespace", cm.Namespace, "Resource.Name", cm.Name)
			return newApplicationError(err, ErrClientK8s)
		}
		return nil
	case "cm_settings":
		cm := &corev1.ConfigMap{ObjectMeta: metav1.ObjectMeta{Name: "site-settings-" + d.Name, Namespace: d.Namespace}}
		_, err := controllerruntime.CreateOrUpdate(ctx, r.Client, cm, func() error {
			return updateConfigMapForSiteSettings(ctx, cm, d, r.Client)
		})
		if err != nil {
			log.Error(err, "Failed to ensure Resource", "Kind", cm.TypeMeta.Kind, "Resource.Namespace", cm.Namespace, "Resource.Name", cm.Name)
			return newApplicationError(err, ErrClientK8s)
		}
		return nil
	case "cm_php_cli":
		cm := &corev1.ConfigMap{ObjectMeta: metav1.ObjectMeta{Name: "php-cli-config-" + d.Name, Namespace: d.Namespace}}
		_, err := controllerruntime.CreateOrUpdate(ctx, r.Client, cm, func() error {
			return updateConfigMapForPHPCLI(ctx, cm, d, r.Client)
		})
		if err != nil {
			log.Error(err, "Failed to ensure Resource", "Kind", cm.TypeMeta.Kind, "Resource.Namespace", cm.Namespace, "Resource.Name", cm.Name)
			return newApplicationError(err, ErrClientK8s)
		}
		return nil
	case "dbod_cr":
		dbod := &dbodv1a1.Database{ObjectMeta: metav1.ObjectMeta{Name: d.Name, Namespace: d.Namespace}}
		_, err := controllerruntime.CreateOrUpdate(ctx, r.Client, dbod, func() error {
			return dbodForDrupalSite(dbod, d)
		})
		if err != nil {
			log.Error(err, "Failed to ensure Resource", "Kind", dbod.TypeMeta.Kind, "Resource.Namespace", dbod.Namespace, "Resource.Name", dbod.Name)
			return newApplicationError(err, ErrClientK8s)
		}
		return nil
	case "backup_schedule":
		schedule := &velerov1.Schedule{ObjectMeta: metav1.ObjectMeta{Name: generateScheduleName(d.Namespace, d.Name), Namespace: VeleroNamespace}}
		_, err := controllerruntime.CreateOrUpdate(ctx, r.Client, schedule, func() error {
			return scheduledBackupsForDrupalSite(schedule, d)
		})
		if err != nil {
			log.Error(err, "Failed to ensure Resource", "Kind", schedule.TypeMeta.Kind, "Resource.Namespace", schedule.Namespace, "Resource.Name", schedule.Name)
			return newApplicationError(err, ErrClientK8s)
		}
		return nil
	case "tekton_extra_perm_rbac":
		// We only need one ClusterRoleBinding for a given project. Therefore the naming. It gets created by any of the sites in
		// the project if it doesn't exist. We don't delete it specifically as well, it can be handled with project deletion
		rbac := &rbacv1.ClusterRoleBinding{ObjectMeta: metav1.ObjectMeta{Name: "tektoncd-extra-permissions-" + d.Namespace}}
		_, err := controllerruntime.CreateOrUpdate(ctx, r.Client, rbac, func() error {
			return clusterRoleBindingForTektonExtraPermission(rbac, d)
		})
		if err != nil {
			log.Error(err, "Failed to ensure Resource", "Kind", rbac.TypeMeta.Kind, "Resource.Name", rbac.Name)
		}
		return nil
	case "cronjob_crontask":
		databaseSecret := databaseSecretName(d)
		if len(databaseSecret) == 0 {
			return nil
		}
		// This ensures we have cron function for the website, see: https://gitlab.cern.ch/webservices/webframeworks-planning/-/issues/437
		cron := &batchbeta1.CronJob{ObjectMeta: metav1.ObjectMeta{Name: "cronjob-" + d.Name, Namespace: d.Namespace}}
		_, err := controllerruntime.CreateOrUpdate(ctx, r.Client, cron, func() error {
			log.V(3).Info("Ensuring Resource", "Kind", cron.TypeMeta.Kind, "Resource.Namespace", cron.Namespace, "Resource.Name", cron.Name)
			return cronjobForDrupalSite(cron, databaseSecret, d)
		})
		if err != nil {
			log.Error(err, "Failed to ensure Resource", "Kind", cron.TypeMeta.Kind, "Resource.Namespace", cron.Namespace, "Resource.Name", cron.Name)
			return newApplicationError(err, ErrClientK8s)
		}
		return nil
	case "svc_redis":
		service := &corev1.Service{ObjectMeta: metav1.ObjectMeta{Name: "redis-" + d.Name, Namespace: d.Namespace}}
		_, err := controllerruntime.CreateOrUpdate(ctx, r.Client, service, func() error {
			return serviceForRedis(service, d)
		})
		if err != nil {
			log.Error(err, "Failed to ensure Resource", "Kind", service.TypeMeta.Kind, "Resource.Namespace", service.Namespace, "Resource.Name", service.Name)
			return newApplicationError(err, ErrClientK8s)
		}
		return nil
	case "secret_redis":
		secret := &corev1.Secret{ObjectMeta: metav1.ObjectMeta{Name: "redis-" + d.Name, Namespace: d.Namespace}}
		_, err := controllerruntime.CreateOrUpdate(ctx, r.Client, secret, func() error {
			return secretForRedis(secret, d)
		})
		if err != nil {
			log.Error(err, "Failed to ensure Resource", "Kind", secret.TypeMeta.Kind, "Resource.Namespace", secret.Namespace, "Resource.Name", secret.Name)
			return newApplicationError(err, ErrClientK8s)
		}
		return nil
	case "gitlab_trigger_secret":
		gitlab_trigger_secret := &corev1.Secret{ObjectMeta: metav1.ObjectMeta{Name: "gitlab-trigger-secret-" + d.Name, Namespace: d.Namespace}}
		_, err := controllerruntime.CreateOrUpdate(ctx, r.Client, gitlab_trigger_secret, func() error {
			log.V(3).Info("Ensuring Resource", "Kind", gitlab_trigger_secret.TypeMeta.Kind, "Resource.Namespace", gitlab_trigger_secret.Namespace, "Resource.Name", gitlab_trigger_secret.Name)
			return secretForS2iGitlabTrigger(gitlab_trigger_secret, d)
		})
		if err != nil {
			log.Error(err, "Failed to ensure Resource", "Kind", gitlab_trigger_secret.TypeMeta.Kind, "Resource.Namespace", gitlab_trigger_secret.Namespace, "Resource.Name", gitlab_trigger_secret.Name)
			return newApplicationError(err, ErrClientK8s)
		}
		return nil
	default:
		return newApplicationError(nil, ErrFunctionDomain)
	}
}

/*
ensureDrupalDeployment is similar to ensureResourceX, but for the Drupal server deployment, which requires extra information.
*/
func (r *DrupalSiteReconciler) ensureDrupalDeployment(ctx context.Context, d *webservicesv1a1.DrupalSite, config DeploymentConfig, log logr.Logger) (transientErr reconcileError) {
	deploy := &appsv1.Deployment{ObjectMeta: metav1.ObjectMeta{Name: d.Name, Namespace: d.Namespace}}
	err := r.Get(ctx, types.NamespacedName{Name: deploy.Name, Namespace: deploy.Namespace}, deploy)

	// Check if a deployment exists & if any of the given conditions satisfy
	// In scenarios where, the deployment is deleted during a failed upgrade, this check is needed to bring it back
	if err == nil && (d.Annotations["updateInProgress"] == "true" || d.ConditionTrue("CodeUpdateFailed") || d.ConditionTrue("DBUpdatesFailed")) {
		return nil
	}
	if databaseSecret := databaseSecretName(d); len(databaseSecret) != 0 {
		deploy := &appsv1.Deployment{ObjectMeta: metav1.ObjectMeta{Name: d.Name, Namespace: d.Namespace}}
		_, err = controllerruntime.CreateOrUpdate(ctx, r.Client, deploy, func() error {
			releaseID := releaseID(d)
			return deploymentForDrupalSite(deploy, databaseSecret, d, releaseID, config)
		})
		if err != nil {
			log.Error(err, "Failed to ensure Resource", "Kind", deploy.TypeMeta.Kind, "Resource.Namespace", deploy.Namespace, "Resource.Name", deploy.Name)
			return newApplicationError(err, ErrClientK8s)
		}
	}
	return nil
}

/*
ensureRedisDeployment is similar to ensureResourceX, but for the Redis deployment, which requires extra information.
*/
func (r *DrupalSiteReconciler) ensureRedisDeployment(ctx context.Context, d *webservicesv1a1.DrupalSite, config DeploymentConfig, log logr.Logger) (transientErr reconcileError) {
	deployment := &appsv1.Deployment{ObjectMeta: metav1.ObjectMeta{Name: "redis-" + d.Name, Namespace: d.Namespace}}
	_, err := controllerruntime.CreateOrUpdate(ctx, r.Client, deployment, func() error {
		return deploymentForRedis(deployment, d, config)
	})
	if err != nil {
		log.Error(err, "Failed to ensure Resource", "Kind", deployment.TypeMeta.Kind, "Resource.Namespace", deployment.Namespace, "Resource.Name", deployment.Name)
		return newApplicationError(err, ErrClientK8s)
	}
	return nil
}

func cronjobForDrupalSite(currentobject *batchbeta1.CronJob, databaseSecret string, drupalsite *webservicesv1a1.DrupalSite) error {
	var jobsHistoryLimit int32 = 1
	var jobBackoffLimit int32 = 1
	var isCriticalSite string = "false"
	if drupalsite.Spec.QoSClass == webservicesv1a1.QoSCritical {
		isCriticalSite = "true"
	}
	if currentobject.Labels == nil {
		currentobject.Labels = map[string]string{}
	}
	if currentobject.Annotations == nil {
		currentobject.Annotations = map[string]string{}
	}
	ls := labelsForDrupalSite(drupalsite.Name)
	ls["app"] = "cronjob"
	for k, v := range ls {
		currentobject.Labels[k] = v
	}
	addOwnerRefToObject(currentobject, asOwner(drupalsite))
	if currentobject.CreationTimestamp.IsZero() {
		randomMinute := rand.Intn(30)
		currentobject.Spec = batchbeta1.CronJobSpec{
			// Every random'th min, random'th min + 30  every hour, this is based on https://en.wikipedia.org/wiki/Cron
			Schedule: strconv.Itoa(randomMinute) + "," + strconv.Itoa(randomMinute+30) + " * * * *",
			// The default is 3, last job should suffice
			SuccessfulJobsHistoryLimit: &jobsHistoryLimit,
			// Default "Allow" policy may lead into trouble, see: https://gitlab.cern.ch/webservices/webframeworks-planning/-/issues/553
			ConcurrencyPolicy: batchbeta1.ReplaceConcurrent,
			JobTemplate: batchbeta1.JobTemplateSpec{
				Spec: batchv1.JobSpec{
					BackoffLimit: &jobBackoffLimit,
					Template: v1.PodTemplateSpec{
						Spec: v1.PodSpec{
							RestartPolicy: "Never",
							Containers: []corev1.Container{
								{
									Name:            "cronjob",
									ImagePullPolicy: "IfNotPresent",
									Command: []string{
										"sh",
										"-c",
										"/operations/run-cron.sh -s " + drupalsite.Name,
									},
									Resources: corev1.ResourceRequirements{
										Requests: corev1.ResourceList{
											corev1.ResourceMemory: resource.MustParse(jobMemoryRequest),
										},
									},
									Env: []corev1.EnvVar{
										{
											Name:  "ENABLE_REDIS",
											Value: isCriticalSite,
										},
									},
									EnvFrom: []corev1.EnvFromSource{
										{
											SecretRef: &corev1.SecretEnvSource{
												LocalObjectReference: corev1.LocalObjectReference{
													Name: databaseSecret,
												},
											},
										},
										{
											SecretRef: &corev1.SecretEnvSource{
												LocalObjectReference: corev1.LocalObjectReference{
													Name: oidcSecretName, //This is always set the same way
												},
											},
										},
									},
									VolumeMounts: []corev1.VolumeMount{
										{
											Name:      "drupal-directory-" + drupalsite.Name,
											MountPath: "/drupal-data",
										},
										{
											Name:      "php-cli-config-volume",
											MountPath: "/usr/local/etc/php/conf.d/config.ini",
											SubPath:   "config.ini",
											ReadOnly:  true,
										},
										{
											Name:      "site-settings-php",
											MountPath: "/app/web/sites/default/settings.php",
											SubPath:   "settings.php",
											ReadOnly:  true,
										},
									},
								},
							},
							Volumes: []corev1.Volume{
								{
									Name: "drupal-directory-" + drupalsite.Name,
									VolumeSource: corev1.VolumeSource{
										PersistentVolumeClaim: &corev1.PersistentVolumeClaimVolumeSource{
											ClaimName: "pv-claim-" + drupalsite.Name,
										},
									},
								},
								{
									Name: "php-cli-config-volume",
									VolumeSource: corev1.VolumeSource{
										ConfigMap: &corev1.ConfigMapVolumeSource{
											LocalObjectReference: corev1.LocalObjectReference{
												Name: "php-cli-config-" + drupalsite.Name,
											},
										},
									},
								},
								{
									Name: "site-settings-php",
									VolumeSource: corev1.VolumeSource{
										ConfigMap: &corev1.ConfigMapVolumeSource{
											LocalObjectReference: corev1.LocalObjectReference{
												Name: "site-settings-" + drupalsite.Name,
											},
										},
									},
								},
							},
						},
					},
				},
			}}
	}
	for i := range currentobject.Spec.JobTemplate.Spec.Template.Spec.Containers {
		addOrRemoveRedisEnvironment(&currentobject.Spec.JobTemplate.Spec.Template.Spec.Containers[i], drupalsite)
	}

	for i, container := range currentobject.Spec.JobTemplate.Spec.Template.Spec.Containers {
		switch container.Name {
		case "cronjob":
			if len(drupalsite.Status.Failsafe) > 0 {
				currentobject.Spec.JobTemplate.Spec.Template.Spec.Containers[i].Image = sitebuilderImageRefToUse(drupalsite, drupalsite.Status.Failsafe).Name
			} else {
				currentobject.Spec.JobTemplate.Spec.Template.Spec.Containers[i].Image = sitebuilderImageRefToUse(drupalsite, releaseID(drupalsite)).Name
			}
		}
	}

	return nil
}

// ensureNoExtraRouteResource uses the current SiteURL resource as reference and deletes any extra route
func (r *DrupalSiteReconciler) ensureNoExtraRouteResource(ctx context.Context, d *webservicesv1a1.DrupalSite, label string, log logr.Logger) (transientErr reconcileError) {
	ls := labelsForDrupalSite(d.Name)
	ls["app"] = "drupal"
	ls["route"] = label
	existingRoutes := &routev1.RouteList{}
	routeLabels, err := metav1.LabelSelectorAsSelector(&metav1.LabelSelector{
		MatchLabels: ls,
	})
	if err != nil {
		return newApplicationError(err, ErrFunctionDomain)
	}
	options := client.ListOptions{
		Namespace:     d.Namespace,
		LabelSelector: routeLabels,
	}
	err = r.Client.List(context.TODO(), existingRoutes, &options)
	if err != nil {
		log.Error(err, "Couldn't query routes with the given labels")
		return newApplicationError(err, ErrClientK8s)
	}
	routeRequestList := d.Spec.SiteURL
	routesToRemove := []webservicesv1a1.Url{}
	for _, route := range existingRoutes.Items {
		flag := false
		for _, req := range routeRequestList {
			if label == "webdav" {
				req = "webdav-" + req
			}
			if string(req) == route.Spec.Host {
				flag = true
				continue
			}
		}
		if !flag {
			routesToRemove = append(routesToRemove, webservicesv1a1.Url(route.Spec.Host))
		}
	}
	for _, route := range routesToRemove {
		if transientErr := r.ensureNoRoute(ctx, d, string(route), log); transientErr != nil {
			return transientErr
		}
	}
	return nil
}

// ensureNoExtraOidcReturnUriResource uses the current SiteURL resource as reference and deletes any extra oidcReturnURI
func (r *DrupalSiteReconciler) ensureNoExtraOidcReturnUriResource(ctx context.Context, d *webservicesv1a1.DrupalSite, label string, log logr.Logger) (transientErr reconcileError) {
	ls := labelsForDrupalSite(d.Name)
	ls["app"] = "drupal"
	ls["oidcReturnURI"] = label
	existingOidcReturnUris := &authz.OidcReturnURIList{}
	oidcReturnUriLabels, err := metav1.LabelSelectorAsSelector(&metav1.LabelSelector{
		MatchLabels: ls,
	})
	if err != nil {
		return newApplicationError(err, ErrFunctionDomain)
	}
	options := client.ListOptions{
		Namespace:     d.Namespace,
		LabelSelector: oidcReturnUriLabels,
	}
	err = r.Client.List(context.TODO(), existingOidcReturnUris, &options)
	if err != nil {
		log.Error(err, "Couldn't query oidcReturnUris with the given labels")
		return newApplicationError(err, ErrClientK8s)
	}
	oidcReturnUriRequestList := d.Spec.SiteURL
	oidcReturnUrisToRemove := []string{}
	for _, route := range existingOidcReturnUris.Items {
		flag := false
		for _, req := range oidcReturnUriRequestList {
			url, err := url.Parse(route.Spec.RedirectURI)
			if err != nil {
				return newApplicationError(err, ErrFunctionDomain)
			}
			if string(req) == url.Host {
				flag = true
				continue
			}
		}
		if !flag {
			url, err := url.Parse(route.Spec.RedirectURI)
			if err != nil {
				return newApplicationError(err, ErrFunctionDomain)
			}
			oidcReturnUrisToRemove = append(oidcReturnUrisToRemove, url.Host)
		}
	}
	for _, oidcReturnURI := range oidcReturnUrisToRemove {
		if transientErr := r.ensureNoReturnURI(ctx, d, oidcReturnURI, log); transientErr != nil {
			return transientErr
		}
	}
	return nil
}

// ensureNoRoute ensures there is no route object for the drupalsite
func (r *DrupalSiteReconciler) ensureNoRoute(ctx context.Context, d *webservicesv1a1.DrupalSite, Url string, log logr.Logger) (transientErr reconcileError) {
	hash := md5.Sum([]byte(Url))
	route := &routev1.Route{ObjectMeta: metav1.ObjectMeta{Name: d.Name + "-" + hex.EncodeToString(hash[0:4]), Namespace: d.Namespace}}
	if err := r.Get(ctx, types.NamespacedName{Name: route.Name, Namespace: route.Namespace}, route); err != nil {
		switch {
		case k8sapierrors.IsNotFound(err):
			return nil
		default:
			return newApplicationError(err, ErrClientK8s)
		}
	}
	if err := r.Delete(ctx, route); err != nil {
		return newApplicationError(err, ErrClientK8s)
	}
	return nil
}

// ensureNoReturnURI ensures there is no OIDC Return URI object for the drupalsite
func (r *DrupalSiteReconciler) ensureNoReturnURI(ctx context.Context, d *webservicesv1a1.DrupalSite, Url string, log logr.Logger) (transientErr reconcileError) {
	hash := md5.Sum([]byte(Url))
	oidc_return_uri := &authz.OidcReturnURI{}
	if err := r.Get(ctx, types.NamespacedName{Name: d.Name + "-" + hex.EncodeToString(hash[0:4]), Namespace: d.Namespace}, oidc_return_uri); err != nil {
		switch {
		case k8sapierrors.IsNotFound(err):
			return nil
		default:
			return newApplicationError(err, ErrClientK8s)
		}
	}
	if err := r.Delete(ctx, oidc_return_uri); err != nil {
		return newApplicationError(err, ErrClientK8s)
	}
	return nil
}

// ensureNoSchedule ensures there is no Schedule object for the drupalsite
func (r *DrupalSiteReconciler) ensureNoSchedule(ctx context.Context, d *webservicesv1a1.DrupalSite, log logr.Logger) (transientErr reconcileError) {
	schedule := &velerov1.Schedule{}
	if err := r.Get(ctx, types.NamespacedName{Name: generateScheduleName(d.Namespace, d.Name), Namespace: VeleroNamespace}, schedule); err != nil {
		switch {
		case k8sapierrors.IsNotFound(err):
			return nil
		default:
			return newApplicationError(err, ErrClientK8s)
		}
	}
	if err := r.Delete(ctx, schedule); err != nil {
		return newApplicationError(err, ErrClientK8s)
	}
	return nil
}

// ensureNoRedisDeployment ensures there is no redis deployment object for the drupalsite
func (r *DrupalSiteReconciler) ensureNoRedisDeployment(ctx context.Context, d *webservicesv1a1.DrupalSite, log logr.Logger) (transientErr reconcileError) {
	deployment := &appsv1.Deployment{}
	if err := r.Get(ctx, types.NamespacedName{Name: "redis-" + d.Name, Namespace: d.Namespace}, deployment); err != nil {
		switch {
		case k8sapierrors.IsNotFound(err):
			return nil
		default:
			return newApplicationError(err, ErrClientK8s)
		}
	}
	if err := r.Delete(ctx, deployment); err != nil {
		return newApplicationError(err, ErrClientK8s)
	}
	return nil
}

// ensureNoRedisService ensures there is no redis service object for the drupalsite
func (r *DrupalSiteReconciler) ensureNoRedisService(ctx context.Context, d *webservicesv1a1.DrupalSite, log logr.Logger) (transientErr reconcileError) {
	service := &corev1.Service{}
	if err := r.Get(ctx, types.NamespacedName{Name: "redis-" + d.Name, Namespace: d.Namespace}, service); err != nil {
		switch {
		case k8sapierrors.IsNotFound(err):
			return nil
		default:
			return newApplicationError(err, ErrClientK8s)
		}
	}
	if err := r.Delete(ctx, service); err != nil {
		return newApplicationError(err, ErrClientK8s)
	}
	return nil
}

// ensureNoRedisSecret ensures there is no redis secret object for the drupalsite
func (r *DrupalSiteReconciler) ensureNoRedisSecret(ctx context.Context, d *webservicesv1a1.DrupalSite, log logr.Logger) (transientErr reconcileError) {
	secret := &corev1.Secret{}
	if err := r.Get(ctx, types.NamespacedName{Name: "redis-" + d.Name, Namespace: d.Namespace}, secret); err != nil {
		switch {
		case k8sapierrors.IsNotFound(err):
			return nil
		default:
			return newApplicationError(err, ErrClientK8s)
		}
	}
	if err := r.Delete(ctx, secret); err != nil {
		return newApplicationError(err, ErrClientK8s)
	}
	return nil
}

// checkNewBackups returns the list of velero backups that exist for a given site
func (r *DrupalSiteReconciler) checkNewBackups(ctx context.Context, d *webservicesv1a1.DrupalSite, log logr.Logger) (backups []velerov1.Backup, reconcileErr reconcileError) {
	backupList := velerov1.BackupList{}
	backups = make([]velerov1.Backup, 0)
	hash := md5.Sum([]byte(d.Namespace))
	backupLabels, err := metav1.LabelSelectorAsSelector(&metav1.LabelSelector{
		MatchLabels: map[string]string{"drupal.webservices.cern.ch/projectHash": hex.EncodeToString(hash[:])},
	})
	if err != nil {
		reconcileErr = newApplicationError(err, ErrFunctionDomain)
		return
	}
	options := client.ListOptions{
		LabelSelector: backupLabels,
		Namespace:     VeleroNamespace,
	}
	err = r.List(ctx, &backupList, &options)
	switch {
	case err != nil:
		reconcileErr = newApplicationError(err, ErrClientK8s)
	case len(backupList.Items) == 0:
		log.V(3).Info("No backup found with given labels " + backupLabels.String())
	default:
		for i := range backupList.Items {
			if backupList.Items[i].Status.Phase == velerov1.BackupPhaseCompleted {
				backups = append(backups, backupList.Items[i])
			}
		}
	}
	return
}

// labelsForDrupalSite returns the labels for selecting the resources
// belonging to the given drupalSite CR name.
func labelsForDrupalSite(name string) map[string]string {
	return map[string]string{"drupalSite": name}
}

// releaseID is the image tag to use depending on the version and releaseSpec
func releaseID(d *webservicesv1a1.DrupalSite) string {
	return d.Spec.Version.Name + "-" + d.Spec.Version.ReleaseSpec
}

// sitebuilderImageRefToUse returns which base image to use, depending on whether the field `ExtraConfigurationRepo` is set.
// If yes, the S2I buildconfig will be used; sitebuilderImageRefToUse returns the output of imageStreamForDrupalSiteBuilderS2I().
// Otherwise, returns the sitebuilder base
func sitebuilderImageRefToUse(d *webservicesv1a1.DrupalSite, releaseID string) corev1.ObjectReference {
	if len(d.Spec.Configuration.ExtraConfigurationRepo) > 0 {
		return corev1.ObjectReference{
			Kind: "ImageStreamTag",
			Name: "image-registry.openshift-image-registry.svc:5000/" + d.Namespace + "/sitebuilder-s2i-" + d.Name + ":" + releaseID,
		}
	}
	return corev1.ObjectReference{
		Kind: "DockerImage",
		Name: SiteBuilderImage + ":" + releaseID,
	}
}

// imageStreamForDrupalSiteBuilderS2I returns a ImageStream object for Drupal SiteBuilder S2I
func imageStreamForDrupalSiteBuilderS2I(currentobject *imagev1.ImageStream, d *webservicesv1a1.DrupalSite) error {
	addOwnerRefToObject(currentobject, asOwner(d))
	currentobject.Spec.LookupPolicy.Local = true
	if currentobject.Labels == nil {
		currentobject.Labels = map[string]string{}
	}
	ls := labelsForDrupalSite(d.Name)
	ls["app"] = "sitebuilder"
	for k, v := range ls {
		currentobject.Labels[k] = v
	}
	return nil
}

// buildConfigForDrupalSiteBuilderS2I returns a BuildConfig object for Drupal SiteBuilder S2I
func buildConfigForDrupalSiteBuilderS2I(currentobject *buildv1.BuildConfig, d *webservicesv1a1.DrupalSite) error {
	addOwnerRefToObject(currentobject, asOwner(d))
	if currentobject.CreationTimestamp.IsZero() {
		currentobject.Spec = buildv1.BuildConfigSpec{
			CommonSpec: buildv1.CommonSpec{
				Resources:                 BuildResources,
				CompletionDeadlineSeconds: pointer.Int64Ptr(1200),
				Source: buildv1.BuildSource{
					Git: &buildv1.GitBuildSource{
						// TODO: support branches https://gitlab.cern.ch/drupal/paas/drupalsite-operator/-/issues/28
						Ref: "master",
						URI: d.Spec.Configuration.ExtraConfigurationRepo,
					},
				},
				Strategy: buildv1.BuildStrategy{
					SourceStrategy: &buildv1.SourceBuildStrategy{
						From: corev1.ObjectReference{
							Kind: "DockerImage",
							Name: SiteBuilderImage + ":" + releaseID(d),
						},
					},
				},
				Output: buildv1.BuildOutput{
					To: &corev1.ObjectReference{
						Kind: "ImageStreamTag",
						Name: "sitebuilder-s2i-" + d.Name + ":" + releaseID(d),
					},
				},
			},
			Triggers: []buildv1.BuildTriggerPolicy{
				{
					Type: buildv1.ConfigChangeBuildTriggerType,
				},
				{
					Type: buildv1.GitLabWebHookBuildTriggerType,
					GitLabWebHook: &buildv1.WebHookTrigger{
						Secret: "gitlab-trigger-secret-" + d.Name,
					},
				},
			},
		}
	}
	if currentobject.Labels == nil {
		currentobject.Labels = map[string]string{}
	}
	ls := labelsForDrupalSite(d.Name)
	ls["app"] = "sitebuilder"
	for k, v := range ls {
		currentobject.Labels[k] = v
	}
	return nil
}

// dbodForDrupalSite returns a DBOD resource for the the Drupal Site
func dbodForDrupalSite(currentobject *dbodv1a1.Database, d *webservicesv1a1.DrupalSite) error {
	addOwnerRefToObject(currentobject, asOwner(d))
	if currentobject.CreationTimestamp.IsZero() {
		dbID := md5.Sum([]byte(d.Namespace + "-" + d.Name))
		currentobject.Spec = dbodv1a1.DatabaseSpec{
			DatabaseClass: string(d.Spec.Configuration.DatabaseClass),
			DbName:        hex.EncodeToString(dbID[1:10]),
			DbUser:        hex.EncodeToString(dbID[1:10]),
			ExtraLabels: map[string]string{
				"drupalSite": d.Name,
			},
		}
	}
	// Enforce only the drupalsite labels on the resource on every iteration
	if currentobject.Labels == nil {
		currentobject.Labels = map[string]string{}
	}
	ls := labelsForDrupalSite(d.Name)
	ls["app"] = "dbod"
	for k, v := range ls {
		currentobject.Labels[k] = v
	}
	return nil
}

// deploymentForDrupalSite defines the server runtime deployment of a DrupalSite
func deploymentForDrupalSite(currentobject *appsv1.Deployment, databaseSecret string, d *webservicesv1a1.DrupalSite, releaseID string, config DeploymentConfig) error {
	ls := labelsForDrupalSite(d.Name)
	if currentobject.Labels == nil {
		currentobject.Labels = map[string]string{}
	}
	ls["app"] = "drupal"
	for k, v := range ls {
		currentobject.Labels[k] = v
	}

	var isCriticalSite string = "false"
	if d.Spec.QoSClass == webservicesv1a1.QoSCritical {
		isCriticalSite = "true"
	}
	addOwnerRefToObject(currentobject, asOwner(d))
	if currentobject.Annotations == nil {
		currentobject.Annotations = map[string]string{}
	}
	currentobject.Annotations["alpha.image.policy.openshift.io/resolve-names"] = "*"

	// Settings only on creation (not enforced)
	if currentobject.CreationTimestamp.IsZero() {
		currentobject.Spec.Template.ObjectMeta.Annotations = map[string]string{}
		currentobject.Spec.Template.Spec.Containers = []corev1.Container{{Name: "nginx"}, {Name: "php-fpm"}, {Name: "php-fpm-exporter"}, {Name: "webdav"}}

		if len(d.Spec.Configuration.ExtraConfigurationRepo) > 0 {
			// This annotation is required to trigger new rollout, when the imagestream gets updated with a new image for the given tag. Without this, deployments might start running with
			// a wrong image built from a different build, that is left out on the node
			currentobject.Annotations["image.openshift.io/triggers"] = "[{\"from\":{\"kind\":\"ImageStreamTag\",\"name\":\"sitebuilder-s2i-" + d.Name + ":" + releaseID + "\",\"namespace\":\"" + d.Namespace + "\"},\"fieldPath\":\"spec.template.spec.containers[?(@.name==\\\"nginx\\\")].image\",\"pause\":\"false\"},{\"from\":{\"kind\":\"ImageStreamTag\",\"name\":\"sitebuilder-s2i-" + d.Name + ":" + releaseID + "\",\"namespace\":\"" + d.Namespace + "\"},\"fieldPath\":\"spec.template.spec.containers[?(@.name==\\\"php-fpm\\\")].image\",\"pause\":\"false\"}]"
		}

		currentobject.Spec.Selector = &metav1.LabelSelector{
			MatchLabels: ls,
		}
		currentobject.Spec.Template.ObjectMeta.Labels = ls

		if _, bool := d.Annotations["nodeSelectorLabel"]; bool {
			if _, bool = d.Annotations["nodeSelectorValue"]; bool {
				currentobject.Spec.Template.Spec.NodeSelector = map[string]string{
					d.Annotations["nodeSelectorLabel"]: d.Annotations["nodeSelectorValue"],
				}
			}
		}

		currentobject.Spec.Template.Spec.Volumes = []corev1.Volume{
			{
				Name: "drupal-directory-" + d.Name,
				VolumeSource: corev1.VolumeSource{
					PersistentVolumeClaim: &corev1.PersistentVolumeClaimVolumeSource{
						ClaimName: "pv-claim-" + d.Name,
					},
				}},
			{
				Name: "php-config-volume",
				VolumeSource: corev1.VolumeSource{
					ConfigMap: &corev1.ConfigMapVolumeSource{
						LocalObjectReference: corev1.LocalObjectReference{
							Name: "php-fpm-" + d.Name,
						},
					},
				},
			},
			{
				Name: "nginx-config-volume",
				VolumeSource: corev1.VolumeSource{
					ConfigMap: &corev1.ConfigMapVolumeSource{
						LocalObjectReference: corev1.LocalObjectReference{
							Name: "nginx-" + d.Name,
						},
					},
				},
			},
			{
				Name: "site-settings-php",
				VolumeSource: corev1.VolumeSource{
					ConfigMap: &corev1.ConfigMapVolumeSource{
						LocalObjectReference: corev1.LocalObjectReference{
							Name: "site-settings-" + d.Name,
						},
					},
				},
			},
			{
				Name:         "empty-dir",
				VolumeSource: corev1.VolumeSource{EmptyDir: &corev1.EmptyDirVolumeSource{}},
			},
			{
				Name: "webdav-volume",
				VolumeSource: corev1.VolumeSource{
					Secret: &corev1.SecretVolumeSource{
						SecretName: "webdav-secret-" + d.Name,
						Items: []corev1.KeyToPath{
							// Unecessary but garantees no other secrets are mounted
							{
								Key:  "htdigest",
								Path: "htdigest",
							},
						},
					},
				},
			},
			{
				// Tmp Dir storage to address issue https://gitlab.cern.ch/webservices/webframeworks-planning/-/issues/600
				Name: "tmp-dir",
				VolumeSource: corev1.VolumeSource{
					EmptyDir: &corev1.EmptyDirVolumeSource{Medium: corev1.StorageMediumMemory},
				},
			},
			{
				Name: "php-cli-config-volume",
				VolumeSource: corev1.VolumeSource{
					ConfigMap: &corev1.ConfigMapVolumeSource{
						LocalObjectReference: corev1.LocalObjectReference{
							Name: "php-cli-config-" + d.Name,
						},
					},
				},
			},
		}

		for i, container := range currentobject.Spec.Template.Spec.Containers {
			switch container.Name {
			case "nginx":
				// Set to always due to https://gitlab.cern.ch/drupal/paas/drupalsite-operator/-/issues/54
				currentobject.Spec.Template.Spec.Containers[i].ImagePullPolicy = "Always"
				currentobject.Spec.Template.Spec.Containers[i].Ports = []corev1.ContainerPort{{
					ContainerPort: 8080,
					Name:          "nginx",
					Protocol:      "TCP",
				}}
				currentobject.Spec.Template.Spec.Containers[i].Env = []corev1.EnvVar{
					{
						Name:  "DRUPAL_SHARED_VOLUME",
						Value: "/drupal-data",
					},
				}
				currentobject.Spec.Template.Spec.Containers[i].VolumeMounts = []corev1.VolumeMount{
					{
						Name:      "drupal-directory-" + d.Name,
						MountPath: "/drupal-data",
					},
					{
						Name:      "nginx-config-volume",
						MountPath: "/etc/nginx/custom.conf",
						SubPath:   "custom.conf",
						ReadOnly:  true,
					},
					{
						Name:      "empty-dir",
						MountPath: "/var/run/",
					},
				}
				// TODO: add readiness probe. Tmp removed due to https://gitlab.cern.ch/webservices/webframeworks-planning/-/issues/542
			case "php-fpm":
				// Set to always due to https://gitlab.cern.ch/drupal/paas/drupalsite-operator/-/issues/54
				currentobject.Spec.Template.Spec.Containers[i].ImagePullPolicy = "Always"
				currentobject.Spec.Template.Spec.Containers[i].Ports = []corev1.ContainerPort{{
					ContainerPort: 9000,
					Name:          "php-fpm",
					Protocol:      "TCP",
				}}
				currentobject.Spec.Template.Spec.Containers[i].Env = []corev1.EnvVar{
					{
						Name:  "DRUPAL_SHARED_VOLUME",
						Value: "/drupal-data",
					},
					{
						Name:  "SMTPHOST",
						Value: SMTPHost,
					},
					{
						Name:  "ENABLE_REDIS",
						Value: isCriticalSite,
					},
				}
				currentobject.Spec.Template.Spec.Containers[i].EnvFrom = []corev1.EnvFromSource{
					{
						SecretRef: &corev1.SecretEnvSource{
							LocalObjectReference: corev1.LocalObjectReference{
								Name: databaseSecret,
							},
						},
					},
					{
						SecretRef: &corev1.SecretEnvSource{
							LocalObjectReference: corev1.LocalObjectReference{
								Name: oidcSecretName, //This is always set the same way
							},
						},
					},
				}
				currentobject.Spec.Template.Spec.Containers[i].VolumeMounts = []corev1.VolumeMount{
					{
						Name:      "drupal-directory-" + d.Name,
						MountPath: "/drupal-data",
					},
					{
						Name:      "php-config-volume",
						MountPath: "/usr/local/etc/php-fpm.d/zz-docker.conf",
						SubPath:   "zz-docker.conf",
						ReadOnly:  true,
					},
					{
						Name:      "empty-dir",
						MountPath: "/var/run/",
					},
					{
						Name:      "site-settings-php",
						MountPath: "/app/web/sites/default/settings.php",
						SubPath:   "settings.php",
						ReadOnly:  true,
					},
					{
						// Tmp Dir storage to address issue https://gitlab.cern.ch/webservices/webframeworks-planning/-/issues/600
						Name:      "tmp-dir",
						MountPath: "/tmp",
					},
					{
						Name:      "php-cli-config-volume",
						MountPath: "/usr/local/etc/php/conf.d/config.ini",
						SubPath:   "config.ini",
						ReadOnly:  true,
					},
				}
			case "php-fpm-exporter":
				// Set to always due to https://gitlab.cern.ch/drupal/paas/drupalsite-operator/-/issues/54
				currentobject.Spec.Template.Spec.Containers[i].ImagePullPolicy = "Always"
				// Port on which to expose metrics
				currentobject.Spec.Template.Spec.Containers[i].Ports = []corev1.ContainerPort{{
					ContainerPort: 9253,
					Name:          "php-fpm-metrics",
					Protocol:      "TCP",
				}}
				currentobject.Spec.Template.Spec.Containers[i].Env = []corev1.EnvVar{
					{
						Name:  "PHP_FPM_SCRAPE_URI",
						Value: "unix:///var/run/drupal.sock;/_site/_php-fpm-status",
					},
				}
				currentobject.Spec.Template.Spec.Containers[i].VolumeMounts = []corev1.VolumeMount{
					{
						Name:      "empty-dir",
						MountPath: "/var/run/",
					},
				}
			case "webdav":
				// Set to always due to https://gitlab.cern.ch/drupal/paas/drupalsite-operator/-/issues/54
				currentobject.Spec.Template.Spec.Containers[i].ImagePullPolicy = "Always"
				currentobject.Spec.Template.Spec.Containers[i].Ports = []corev1.ContainerPort{{
					ContainerPort: 8008,
					Name:          "webdav",
					Protocol:      "TCP",
				}}
				//TODO: mount password as file
				currentobject.Spec.Template.Spec.Containers[i].Env = []corev1.EnvVar{
					{
						Name:  "DRUPAL_SHARED_VOLUME",
						Value: "/drupal-data",
					},
				}
				currentobject.Spec.Template.Spec.Containers[i].VolumeMounts = []corev1.VolumeMount{
					{
						Name:      "drupal-directory-" + d.Name,
						MountPath: "/drupal-data",
					},
					{
						Name:      "webdav-volume",
						MountPath: "/webdav/htdigest",
						ReadOnly:  true,
					},
					{
						Name:      "empty-dir",
						MountPath: "/var/run/",
					},
				}
			}
		}

	}

	// Settings on update
	_, annotExists := currentobject.Spec.Template.ObjectMeta.Annotations["releaseID"]
	if !annotExists || d.Status.ReleaseID.Failsafe == "" || currentobject.Spec.Template.ObjectMeta.Annotations["releaseID"] != releaseID {
		for i, container := range currentobject.Spec.Template.Spec.Containers {
			switch container.Name {
			case "nginx":
				currentobject.Spec.Template.Spec.Containers[i].Image = sitebuilderImageRefToUse(d, releaseID).Name
			case "php-fpm":
				currentobject.Spec.Template.Spec.Containers[i].Image = sitebuilderImageRefToUse(d, releaseID).Name
			case "php-fpm-exporter":
				currentobject.Spec.Template.Spec.Containers[i].Image = PhpFpmExporterImage
			case "webdav":
				currentobject.Spec.Template.Spec.Containers[i].Image = WebDAVImage
			}
		}
	}

	// Settings enforced always

	for i, container := range currentobject.Spec.Template.Spec.Containers {
		switch container.Name {
		case "nginx":
			currentobject.Spec.Template.Spec.Containers[i].Command = []string{"/run-nginx.sh"}
			currentobject.Spec.Template.Spec.Containers[i].Resources = config.nginxResources
		case "php-fpm":
			currentobject.Spec.Template.Spec.Containers[i].Command = []string{"php-fpm"}
			currentobject.Spec.Template.Spec.Containers[i].Resources = config.phpResources
			for j, item := range currentobject.Spec.Template.Spec.Containers[i].Env {
				if item.Name == "ENABLE_REDIS" {
					currentobject.Spec.Template.Spec.Containers[i].Env[j].Value = isCriticalSite
				}
			}
		case "php-fpm-exporter":
			currentobject.Spec.Template.Spec.Containers[i].Resources = config.phpExporterResources
		case "webdav":
			currentobject.Spec.Template.Spec.Containers[i].Command = []string{"php-fpm"}
			currentobject.Spec.Template.Spec.Containers[i].Resources = config.webDAVResources
		}
	}
	currentobject.Spec.Replicas = &config.replicas
	// Add an annotation to be able to verify what releaseID of pod is running. Did not use labels, as it will affect the labelselector for the deployment and might cause downtime
	currentobject.Spec.Template.ObjectMeta.Annotations["releaseID"] = releaseID
	currentobject.Spec.Template.ObjectMeta.Annotations["pre.hook.backup.velero.io/container"] = "php-fpm"
	currentobject.Spec.Template.ObjectMeta.Annotations["pre.hook.backup.velero.io/command"] = "[\"sh\",\"-c\", \"/operations/database-backup.sh -f database_backup.sql\"]"
	// Since we have varying sizes of databases, the timeout needs to be large enough. Else the backups will fail.
	// Ref: https://gitlab.cern.ch/drupal/paas/drupalsite-operator/-/issues/71
	currentobject.Spec.Template.ObjectMeta.Annotations["pre.hook.backup.velero.io/timeout"] = "90m"
	currentobject.Spec.Template.ObjectMeta.Annotations["backup.velero.io/backup-volumes"] = "drupal-directory-" + d.Name

	for i, container := range currentobject.Spec.Template.Spec.Containers {
		switch container.Name {
		case "php-fpm":
			addOrRemoveRedisEnvironment(&currentobject.Spec.Template.Spec.Containers[i], d)
		}
	}

	// Ensure availability zones for critical sites if enabled
	if d.Spec.QoSClass == webservicesv1a1.QoSCritical && EnableTopologySpread {
		currentobject.Annotations["critical-site"] = "true"
		currentobject.Spec.Template.Spec.TopologySpreadConstraints = []v1.TopologySpreadConstraint{
			{
				LabelSelector: &metav1.LabelSelector{
					MatchLabels: map[string]string{
						"drupalSite": d.Name,
					},
				},
				TopologyKey:       "topology.kubernetes.io/zone",
				MaxSkew:           1,
				WhenUnsatisfiable: v1.UnsatisfiableConstraintAction("DoNotSchedule"),
			},
		}
	} else {
		currentobject.Spec.Template.Spec.TopologySpreadConstraints = []v1.TopologySpreadConstraint{}
	}

	return nil
}

// secretForWebDAV returns a Secret object
func secretForWebDAV(currentobject *corev1.Secret, d *webservicesv1a1.DrupalSite) error {
	addOwnerRefToObject(currentobject, asOwner(d))
	currentobject.Type = "kubernetes.io/opaque"
	encryptedOpaquePassword := encryptBasicAuthPassword(d.Spec.Configuration.WebDAVPassword)
	currentobject.StringData = map[string]string{
		"htdigest": encryptedOpaquePassword,
	}
	if currentobject.Labels == nil {
		currentobject.Labels = map[string]string{}
	}
	ls := labelsForDrupalSite(d.Name)
	ls["app"] = "drupal"
	for k, v := range ls {
		currentobject.Labels[k] = v
	}
	return nil
}

// persistentVolumeClaimForDrupalSite returns a PVC object
func persistentVolumeClaimForDrupalSite(currentobject *corev1.PersistentVolumeClaim, d *webservicesv1a1.DrupalSite) error {
	addOwnerRefToObject(currentobject, asOwner(d))
	if currentobject.CreationTimestamp.IsZero() {
		currentobject.Spec = corev1.PersistentVolumeClaimSpec{
			// Selector: &metav1.LabelSelector{
			// 	MatchLabels: ls,
			// },
			StorageClassName: pointer.StringPtr("cephfs-no-backup"),
			AccessModes:      []corev1.PersistentVolumeAccessMode{"ReadWriteMany"},
			Resources: corev1.ResourceRequirements{
				Requests: corev1.ResourceList{
					corev1.ResourceName(corev1.ResourceStorage): resource.MustParse(d.Spec.Configuration.DiskSize),
				},
			},
		}
	}
	if currentobject.Labels == nil {
		currentobject.Labels = map[string]string{}
	}
	ls := labelsForDrupalSite(d.Name)
	ls["app"] = "drupal"
	for k, v := range ls {
		currentobject.Labels[k] = v
	}
	return nil
}

// serviceForDrupalSite returns a service object
func serviceForDrupalSite(currentobject *corev1.Service, d *webservicesv1a1.DrupalSite) error {
	if currentobject.Labels == nil {
		currentobject.Labels = map[string]string{}
	}
	ls := labelsForDrupalSite(d.Name)
	ls["app"] = "drupal"
	for k, v := range ls {
		currentobject.Labels[k] = v
	}

	addOwnerRefToObject(currentobject, asOwner(d))
	currentobject.Spec.Selector = ls
	currentobject.Spec.Ports = []corev1.ServicePort{
		{
			TargetPort: intstr.FromInt(8080),
			Name:       "nginx",
			Port:       80,
			Protocol:   "TCP",
		},
		{
			TargetPort: intstr.FromInt(9253),
			Name:       "php-fpm-exporter",
			Port:       9253,
			Protocol:   "TCP",
		}}
	return nil
}

// routeForDrupalSite returns a route object
func routeForDrupalSite(currentobject *routev1.Route, d *webservicesv1a1.DrupalSite, Url string) error {
	addOwnerRefToObject(currentobject, asOwner(d))
	currentobject.Spec.TLS = &routev1.TLSConfig{
		InsecureEdgeTerminationPolicy: "Redirect",
		Termination:                   "edge",
	}
	currentobject.Spec.To = routev1.RouteTargetReference{
		Kind:   "Service",
		Name:   d.Name,
		Weight: pointer.Int32Ptr(100),
	}
	currentobject.Spec.Port = &routev1.RoutePort{
		TargetPort: intstr.FromInt(8080),
	}

	if currentobject.Annotations == nil {
		currentobject.Annotations = map[string]string{}
	}
	if currentobject.Labels == nil {
		currentobject.Labels = map[string]string{}
	}
	ls := labelsForDrupalSite(d.Name)
	ls["app"] = "drupal"
	// Adding a new label to be able to filter and remove extra resources when there are changes in Spec.SiteURL
	ls["route"] = "drupal"
	for k, v := range ls {
		currentobject.Labels[k] = v
	}

	if _, exists := d.Annotations["haproxy.router.openshift.io/ip_whitelist"]; exists {
		currentobject.Annotations["haproxy.router.openshift.io/ip_whitelist"] = d.Annotations["haproxy.router.openshift.io/ip_whitelist"]
	}
	// Set timeout to 60sec: https://gitlab.cern.ch/webservices/webframeworks-planning/-/issues/642
	currentobject.Annotations["haproxy.router.openshift.io/timeout"] = "60s"
	currentobject.Spec.Host = Url
	return nil
}

// newOidcReturnURI returns a oidcReturnURI object
func newOidcReturnURI(currentobject *authz.OidcReturnURI, d *webservicesv1a1.DrupalSite, Url string) error {
	addOwnerRefToObject(currentobject, asOwner(d))
	url, err := url.Parse(Url)
	if err != nil {
		return err
	}

	if currentobject.Labels == nil {
		currentobject.Labels = map[string]string{}
	}
	ls := labelsForDrupalSite(d.Name)
	ls["app"] = "drupal"
	// Adding a new label to be able to filter and remove extra resources when there are changes in Spec.SiteURL
	ls["oidcReturnURI"] = "drupal"
	for k, v := range ls {
		currentobject.Labels[k] = v
	}

	// This will append `/openid-connect/*` to the URL, guaranteeing all subpaths of the link can be redirected
	url.Path = path.Join(url.Path, "openid-connect")
	returnURI := "http://" + url.String() + "/*" // Hardcoded since with path.Join method creates `%2A` which will not work in the AuthzAPI, and the prefix `http`
	currentobject.Spec = authz.OidcReturnURISpec{
		RedirectURI: returnURI,
	}
	return nil
}

// jobForDrupalSiteInstallation returns a job object thats runs drush
func jobForDrupalSiteInstallation(currentobject *batchv1.Job, databaseSecret string, d *webservicesv1a1.DrupalSite) error {
	ls := labelsForDrupalSite(d.Name)
	var isCriticalSite string = "false"
	if d.Spec.QoSClass == webservicesv1a1.QoSCritical {
		isCriticalSite = "true"
	}
	if currentobject.CreationTimestamp.IsZero() {
		addOwnerRefToObject(currentobject, asOwner(d))
		currentobject.Labels = map[string]string{}
		currentobject.Spec.Template.ObjectMeta = metav1.ObjectMeta{
			Labels: ls,
		}
		currentobject.Spec.BackoffLimit = pointer.Int32Ptr(3)
		// Increasing the limit temporarily to fix https://gitlab.cern.ch/webservices/webframeworks-planning/-/issues/479
		currentobject.Spec.Template.Spec = corev1.PodSpec{
			InitContainers: []corev1.Container{{
				Image:           "bash",
				Name:            "pvc-init",
				ImagePullPolicy: "IfNotPresent",
				Command:         []string{"bash", "-c", "mkdir -p $DRUPAL_SHARED_VOLUME/{files,private,modules,themes}"},
				Env: []corev1.EnvVar{
					{
						Name:  "DRUPAL_SHARED_VOLUME",
						Value: "/drupal-data",
					},
				},
				VolumeMounts: []corev1.VolumeMount{{
					Name:      "drupal-directory-" + d.Name,
					MountPath: "/drupal-data",
				}},
			}},
			RestartPolicy: "Never",
			Containers: []corev1.Container{{
				Image:           sitebuilderImageRefToUse(d, releaseID(d)).Name,
				Name:            "drush",
				ImagePullPolicy: "Always",
				Resources: corev1.ResourceRequirements{
					Requests: corev1.ResourceList{
						corev1.ResourceMemory: resource.MustParse(jobMemoryRequest),
					},
				},
				Command: siteInstallJobForDrupalSite(),
				Env: []corev1.EnvVar{
					{
						Name:  "DRUPAL_SHARED_VOLUME",
						Value: "/drupal-data",
					},
					{
						Name:  "SMTPHOST",
						Value: SMTPHost,
					},
					{
						Name:  "ENABLE_REDIS",
						Value: isCriticalSite,
					},
				},
				EnvFrom: []corev1.EnvFromSource{
					{
						SecretRef: &corev1.SecretEnvSource{
							LocalObjectReference: corev1.LocalObjectReference{
								Name: databaseSecret,
							},
						},
					},
					{
						SecretRef: &corev1.SecretEnvSource{
							LocalObjectReference: corev1.LocalObjectReference{
								Name: oidcSecretName, //This is always set the same way
							},
						},
					},
				},
				VolumeMounts: []corev1.VolumeMount{
					{
						Name:      "drupal-directory-" + d.Name,
						MountPath: "/drupal-data",
					},
					{
						Name:      "php-cli-config-volume",
						MountPath: "/usr/local/etc/php/conf.d/config.ini",
						SubPath:   "config.ini",
						ReadOnly:  true,
					},
					{
						Name:      "site-settings-php",
						MountPath: "/app/web/sites/default/settings.php",
						SubPath:   "settings.php",
						ReadOnly:  true,
					},
				},
			}},
			Volumes: []corev1.Volume{
				{
					Name: "drupal-directory-" + d.Name,
					VolumeSource: corev1.VolumeSource{
						PersistentVolumeClaim: &corev1.PersistentVolumeClaimVolumeSource{
							ClaimName: "pv-claim-" + d.Name,
						},
					},
				},
				{
					Name: "site-settings-php",
					VolumeSource: corev1.VolumeSource{
						ConfigMap: &corev1.ConfigMapVolumeSource{
							LocalObjectReference: corev1.LocalObjectReference{
								Name: "site-settings-" + d.Name,
							},
						},
					},
				},
				{
					Name: "php-cli-config-volume",
					VolumeSource: corev1.VolumeSource{
						ConfigMap: &corev1.ConfigMapVolumeSource{
							LocalObjectReference: corev1.LocalObjectReference{
								Name: "php-cli-config-" + d.Name,
							},
						},
					},
				},
			},
		}
		for i := range currentobject.Spec.Template.Spec.Containers {
			addOrRemoveRedisEnvironment(&currentobject.Spec.Template.Spec.Containers[i], d)
		}
		ls["app"] = "drush"
		for k, v := range ls {
			currentobject.Labels[k] = v
		}
	}
	return nil
}

// jobForDrupalSiteClone returns a job object thats clones a drupalsite
func jobForDrupalSiteClone(currentobject *batchv1.Job, databaseSecret string, d *webservicesv1a1.DrupalSite) error {
	ls := labelsForDrupalSite(d.Name)
	var isCriticalSite string = "false"
	if d.Spec.QoSClass == webservicesv1a1.QoSCritical {
		isCriticalSite = "true"
	}
	if currentobject.CreationTimestamp.IsZero() {
		addOwnerRefToObject(currentobject, asOwner(d))
		currentobject.Labels = map[string]string{}
		currentobject.Spec.Template.ObjectMeta = metav1.ObjectMeta{
			Labels: ls,
		}
		currentobject.Spec.Template.Spec = corev1.PodSpec{
			InitContainers: []corev1.Container{
				{
					Image:           sitebuilderImageRefToUse(d, releaseID(d)).Name,
					Name:            "src-db-backup",
					ImagePullPolicy: "Always",
					Command:         takeBackup("dbBackUp.sql"),
					Resources: corev1.ResourceRequirements{
						Requests: corev1.ResourceList{
							corev1.ResourceMemory: resource.MustParse(jobMemoryRequest),
						},
					},
					Env: []corev1.EnvVar{
						{
							Name:  "DRUPAL_SHARED_VOLUME",
							Value: "/drupal-data",
						},
					},
					EnvFrom: []corev1.EnvFromSource{
						{
							SecretRef: &corev1.SecretEnvSource{
								LocalObjectReference: corev1.LocalObjectReference{
									Name: "dbcredentials-" + string(d.Spec.Configuration.CloneFrom),
								},
							},
						},
					},
					VolumeMounts: []corev1.VolumeMount{{
						Name:      "drupal-directory-" + string(d.Spec.Configuration.CloneFrom),
						MountPath: "/drupal-data",
					}},
				},
			},
			RestartPolicy: "Never",
			Containers: []corev1.Container{{
				Image:           sitebuilderImageRefToUse(d, releaseID(d)).Name,
				Name:            "dest-clone",
				ImagePullPolicy: "Always",
				Command:         cloneSource("dbBackUp.sql"),
				Env: []corev1.EnvVar{
					{
						Name:  "DRUPAL_SHARED_VOLUME",
						Value: "/drupal-data-source",
					},
					{
						// Needed for https://gitlab.cern.ch/drupal/paas/cern-drupal-distribution/-/merge_requests/41#note_4919578
						Name:  "ENABLE_REDIS",
						Value: isCriticalSite,
					},
				},
				EnvFrom: []corev1.EnvFromSource{
					{
						SecretRef: &corev1.SecretEnvSource{
							LocalObjectReference: corev1.LocalObjectReference{
								Name: databaseSecret,
							},
						},
					},
					{
						SecretRef: &corev1.SecretEnvSource{
							LocalObjectReference: corev1.LocalObjectReference{
								Name: oidcSecretName, //This is always set the same way
							},
						},
					},
				},
				VolumeMounts: []corev1.VolumeMount{
					{
						Name:      "drupal-directory-" + string(d.Spec.Configuration.CloneFrom),
						MountPath: "/drupal-data-source",
					},
					{
						Name:      "drupal-directory-" + d.Name,
						MountPath: "/drupal-data",
					},
					{
						Name:      "php-cli-config-volume",
						MountPath: "/usr/local/etc/php/conf.d/config.ini",
						SubPath:   "config.ini",
						ReadOnly:  true,
					},
					{
						Name:      "site-settings-php",
						MountPath: "/app/web/sites/default/settings.php",
						SubPath:   "settings.php",
						ReadOnly:  true,
					},
				},
			}},
			Volumes: []corev1.Volume{
				{
					Name: "drupal-directory-" + d.Name,
					VolumeSource: corev1.VolumeSource{
						PersistentVolumeClaim: &corev1.PersistentVolumeClaimVolumeSource{
							ClaimName: "pv-claim-" + d.Name,
						},
					},
				},
				{
					Name: "drupal-directory-" + string(d.Spec.Configuration.CloneFrom),
					VolumeSource: corev1.VolumeSource{
						PersistentVolumeClaim: &corev1.PersistentVolumeClaimVolumeSource{
							ClaimName: "pv-claim-" + string(d.Spec.Configuration.CloneFrom),
						},
					},
				},
				{
					Name: "site-settings-php",
					VolumeSource: corev1.VolumeSource{
						ConfigMap: &corev1.ConfigMapVolumeSource{
							LocalObjectReference: corev1.LocalObjectReference{
								Name: "site-settings-" + d.Name,
							},
						},
					},
				},
				{
					Name: "php-cli-config-volume",
					VolumeSource: corev1.VolumeSource{
						ConfigMap: &corev1.ConfigMapVolumeSource{
							LocalObjectReference: corev1.LocalObjectReference{
								Name: "php-cli-config-" + d.Name,
							},
						},
					},
				},
			},
		}
		for i := range currentobject.Spec.Template.Spec.Containers {
			addOrRemoveRedisEnvironment(&currentobject.Spec.Template.Spec.Containers[i], d)
		}
		ls["app"] = "clone"
		for k, v := range ls {
			currentobject.Labels[k] = v
		}
	}
	return nil
}

// scheduledBackupsForDrupalSite returns a velero Schedule object that creates scheduled backups
func scheduledBackupsForDrupalSite(currentobject *velerov1.Schedule, d *webservicesv1a1.DrupalSite) error {
	// Do not add owner references here. As this object is created in a different namespace. Instead the deletion
	// of this object is handled manually in the 'cleanupDrupalSite' function
	if currentobject.Annotations == nil {
		currentobject.Annotations = map[string]string{}
	}
	if currentobject.Labels == nil {
		currentobject.Labels = map[string]string{}
	}

	hash := md5.Sum([]byte(d.Namespace))
	currentobject.Labels["drupal.webservices.cern.ch/projectHash"] = hex.EncodeToString(hash[:])
	// These labels need to be removed, as annotations support longer values.
	// But this can be done only after upgrading velero to 1.5 or higher which supports propagating annotations
	// from schedules to the backups.
	// ref: https://gitlab.cern.ch/webservices/webframeworks-planning/-/issues/457
	currentobject.Labels["drupal.webservices.cern.ch/project"] = d.Namespace
	currentobject.Labels["drupal.webservices.cern.ch/drupalSite"] = d.Name

	currentobject.Annotations["drupal.webservices.cern.ch/project"] = d.Namespace
	currentobject.Annotations["drupal.webservices.cern.ch/drupalSite"] = d.Name

	if currentobject.CreationTimestamp.IsZero() || len(currentobject.Spec.Schedule) == 0 {
		acceptedHoursForBackup := []string{"20", "21", "22", "23", "0", "1", "2", "3", "4", "5"}
		oddOrEven := []string{"1", "2"}
		randomHour := acceptedHoursForBackup[rand.Intn(len(acceptedHoursForBackup))]
		randomMinute := strconv.Itoa(rand.Intn(60))
		randomAlternateDay := oddOrEven[rand.Intn(len(oddOrEven))]
		currentobject.Spec.Schedule = randomMinute + " " + randomHour + " " + randomAlternateDay + "-31/2 * *"
	}

	currentobject.Spec.Template = velerov1.BackupSpec{
		IncludedNamespaces: []string{d.Namespace},
		IncludedResources:  []string{"pods"},
		// Add label selector to pick up the right pod and the respective PVC
		LabelSelector: &metav1.LabelSelector{
			MatchLabels: map[string]string{
				"app":        "drupal",
				"drupalSite": d.Name,
			},
		},
		// TTL is 14 days. The backups are deleted automatically after this duration
		TTL: metav1.Duration{
			Duration: 14 * 24 * time.Hour,
		},
	}
	currentobject.Spec.UseOwnerReferencesInBackup = pointer.BoolPtr(true)
	return nil
}

// clusterRoleBindingForTektonExtraPermission returns a ClusterRoleBinding object thats binds the tektoncd service account
// with the tektoncd-extra-permissions ClusterRole. This binding grants permissions to create jobs (and only that)
func clusterRoleBindingForTektonExtraPermission(currentobject *rbacv1.ClusterRoleBinding, d *webservicesv1a1.DrupalSite) error {
	currentobject.RoleRef = rbacv1.RoleRef{
		APIGroup: "rbac.authorization.k8s.io",
		Kind:     "ClusterRole",
		Name:     "tektoncd-extra-permissions",
	}

	currentobject.Subjects = []rbacv1.Subject{
		{
			Kind:      "ServiceAccount",
			Name:      "tektoncd",
			Namespace: d.Namespace,
		},
	}
	return nil
}

// secretForS2iGitlabTrigger returns a Secret object for openshift buildconfig gitlab trigger
func secretForS2iGitlabTrigger(currentobject *corev1.Secret, d *webservicesv1a1.DrupalSite) error {
	addOwnerRefToObject(currentobject, asOwner(d))
	currentobject.Type = "kubernetes.io/opaque"
	// All configurations that we do not want to enforce, we set here
	if currentobject.CreationTimestamp.IsZero() {
		encryptedOpaquePassword := generateRandomPassword()
		currentobject.StringData = map[string]string{
			"WebHookSecretKey": encryptedOpaquePassword,
		}
	}
	if currentobject.Labels == nil {
		currentobject.Labels = map[string]string{}
	}
	ls := labelsForDrupalSite(d.Name)
	ls["app"] = "drupal"
	for k, v := range ls {
		currentobject.Labels[k] = v
	}
	return nil
}

// updateConfigMapForPHPFPM modifies the configmap to include the php-fpm settings file,
// but only if it's freshly created
func updateConfigMapForPHPFPM(ctx context.Context, currentobject *corev1.ConfigMap, d *webservicesv1a1.DrupalSite, c client.Client) error {
	configPath := "/tmp/runtime-config/qos-" + string(d.Spec.Configuration.QoSClass) + "/php-fpm.conf"
	content, err := ioutil.ReadFile(configPath)
	if err != nil {
		return newApplicationError(fmt.Errorf("reading PHP-FPM configMap failed: %w", err), ErrFilesystemIO)
	}

	addOwnerRefToObject(currentobject, asOwner(d))

	// All configurations that we do not want to enforce, we set here
	if currentobject.CreationTimestamp.IsZero() {
		// Upstream PHP docker images use zz-docker.conf for configuration and this file gets loaded last (because of 'zz*') and overrides the default configuration loaded from www.conf
		currentobject.Data = map[string]string{
			"zz-docker.conf": string(content),
		}
	}
	if currentobject.Annotations == nil {
		currentobject.Annotations = map[string]string{}
	}
	if currentobject.Labels == nil {
		currentobject.Labels = map[string]string{}
	}
	ls := labelsForDrupalSite(d.Name)
	ls["app"] = "php"
	for k, v := range ls {
		currentobject.Labels[k] = v
	}
	return nil
}

// updateConfigMapForNginx modifies the configmap to include the Nginx settings file.
// If the file contents change, it rolls out a new deployment.
func updateConfigMapForNginx(ctx context.Context, currentobject *corev1.ConfigMap, d *webservicesv1a1.DrupalSite, c client.Client) error {
	configPath := "/tmp/runtime-config/qos-" + string(d.Spec.Configuration.QoSClass) + "/nginx.conf"
	content, err := ioutil.ReadFile(configPath)
	if err != nil {
		return newApplicationError(fmt.Errorf("reading Nginx configuration failed: %w", err), ErrFilesystemIO)
	}

	addOwnerRefToObject(currentobject, asOwner(d))

	// All configurations that we do not want to enforce, we set here
	if currentobject.CreationTimestamp.IsZero() {
		currentobject.Data = map[string]string{
			"custom.conf": string(content),
		}
	}

	if currentobject.Annotations == nil {
		currentobject.Annotations = map[string]string{}
	}
	if currentobject.Labels == nil {
		currentobject.Labels = map[string]string{}
	}
	ls := labelsForDrupalSite(d.Name)
	ls["app"] = "nginx"
	for k, v := range ls {
		currentobject.Labels[k] = v
	}
	return nil
}

// updateConfigMapForSiteSettings modifies the configmap to include the file settings.php
func updateConfigMapForSiteSettings(ctx context.Context, currentobject *corev1.ConfigMap, d *webservicesv1a1.DrupalSite, c client.Client) error {
	configPath := "/tmp/runtime-config/sitebuilder/settings.php"
	content, err := ioutil.ReadFile(configPath)
	if err != nil {
		return newApplicationError(fmt.Errorf("reading settings.php failed: %w", err), ErrFilesystemIO)
	}

	addOwnerRefToObject(currentobject, asOwner(d))

	// All configurations that we do not want to enforce, we set here
	if currentobject.CreationTimestamp.IsZero() {
		currentobject.Data = map[string]string{
			"settings.php": string(content),
		}
	}

	if currentobject.Labels == nil {
		currentobject.Labels = map[string]string{}
	}
	if currentobject.Annotations == nil {
		currentobject.Annotations = map[string]string{}
	}
	ls := labelsForDrupalSite(d.Name)
	ls["app"] = "nginx"
	for k, v := range ls {
		currentobject.Labels[k] = v
	}
	return nil
}

// updateConfigMapForPHPCLI modifies the configmap to include the file config.ini for php CLI
func updateConfigMapForPHPCLI(ctx context.Context, currentobject *corev1.ConfigMap, d *webservicesv1a1.DrupalSite, c client.Client) error {
	configPath := "/tmp/runtime-config/sitebuilder/config.ini"
	content, err := ioutil.ReadFile(configPath)
	if err != nil {
		return newApplicationError(fmt.Errorf("reading config.ini failed: %w", err), ErrFilesystemIO)
	}

	addOwnerRefToObject(currentobject, asOwner(d))

	// All configurations that we do not want to enforce, we set here
	if currentobject.CreationTimestamp.IsZero() {
		currentobject.Data = map[string]string{
			"config.ini": string(content),
		}
	}

	if currentobject.Labels == nil {
		currentobject.Labels = map[string]string{}
	}
	if currentobject.Annotations == nil {
		currentobject.Annotations = map[string]string{}
	}
	ls := labelsForDrupalSite(d.Name)
	ls["app"] = "php"
	for k, v := range ls {
		currentobject.Labels[k] = v
	}
	return nil
}

// deploymentForRedis defines the redis deployment needed for a DrupalSite with critical QoS
func deploymentForRedis(currentobject *appsv1.Deployment, d *webservicesv1a1.DrupalSite, config DeploymentConfig) error {
	ls := labelsForDrupalSite(d.Name)
	if currentobject.Labels == nil {
		currentobject.Labels = map[string]string{}
	}
	ls["app"] = "redis"
	for k, v := range ls {
		currentobject.Labels[k] = v
	}

	if currentobject.CreationTimestamp.IsZero() {
		addOwnerRefToObject(currentobject, asOwner(d))
		currentobject.Annotations = map[string]string{}
		currentobject.Spec.Template.ObjectMeta.Annotations = map[string]string{}

	}
	currentobject.Spec.Selector = &metav1.LabelSelector{
		MatchLabels: ls,
	}
	currentobject.Spec.Replicas = pointer.Int32Ptr(1)
	currentobject.Spec.Template.ObjectMeta.Labels = ls

	currentobject.Spec.Template.Spec.Volumes = []corev1.Volume{
		{
			Name:         "empty-dir",
			VolumeSource: corev1.VolumeSource{EmptyDir: &corev1.EmptyDirVolumeSource{}},
		},
	}
	currentobject.Spec.Template.Spec.Containers = []corev1.Container{{
		Name:            "redis",
		ImagePullPolicy: "IfNotPresent",
		Image:           "redis:6.2.5",
		Command: []string{
			"/bin/sh",
			"-c",
			"redis-server --requirepass ${REDIS_PASSWORD}",
		},
		EnvFrom: []corev1.EnvFromSource{
			{
				SecretRef: &corev1.SecretEnvSource{
					LocalObjectReference: corev1.LocalObjectReference{
						Name: "redis-" + d.Name,
					},
				},
			},
		},
		Ports: []corev1.ContainerPort{{
			ContainerPort: 6379,
			Name:          "redis",
			Protocol:      "TCP",
		}},
		Resources: config.redisResources,
		ReadinessProbe: &v1.Probe{
			Handler: v1.Handler{
				Exec: &v1.ExecAction{
					Command: []string{
						"/bin/sh",
						"-c",
						"redis-cli -a $REDIS_PASSWORD ping",
					},
				},
			},
			InitialDelaySeconds: 30,
			TimeoutSeconds:      15,
		},
		LivenessProbe: &v1.Probe{
			Handler: v1.Handler{
				TCPSocket: &v1.TCPSocketAction{
					Port: intstr.FromInt(6379),
				},
			},
			InitialDelaySeconds: 30,
			TimeoutSeconds:      5,
		},
		VolumeMounts: []corev1.VolumeMount{
			{
				Name:      "empty-dir",
				MountPath: "/data",
			},
		},
	}}
	return nil
}

// serviceForRedis returns a service object for Redis deployment
func serviceForRedis(currentobject *corev1.Service, d *webservicesv1a1.DrupalSite) error {
	if currentobject.Labels == nil {
		currentobject.Labels = map[string]string{}
	}
	ls := labelsForDrupalSite(d.Name)
	ls["app"] = "redis"
	for k, v := range ls {
		currentobject.Labels[k] = v
	}

	if currentobject.CreationTimestamp.IsZero() {
		addOwnerRefToObject(currentobject, asOwner(d))
		currentobject.Spec.Selector = ls
		currentobject.Spec.Ports = []corev1.ServicePort{
			{
				TargetPort: intstr.FromInt(6379),
				Name:       "redis",
				Port:       6379,
				Protocol:   "TCP",
			},
		}
	}
	return nil
}

// secretForRedis returns a Secret object for Redis deployment
func secretForRedis(currentobject *corev1.Secret, d *webservicesv1a1.DrupalSite) error {
	addOwnerRefToObject(currentobject, asOwner(d))
	currentobject.Type = "kubernetes.io/opaque"
	if currentobject.CreationTimestamp.IsZero() {
		currentobject.StringData = map[string]string{
			"REDIS_PASSWORD": generateRandomPassword(),
		}
	}
	if currentobject.Labels == nil {
		currentobject.Labels = map[string]string{}
	}
	ls := labelsForDrupalSite(d.Name)
	ls["app"] = "redis"
	for k, v := range ls {
		currentobject.Labels[k] = v
	}
	return nil
}

// addOwnerRefToObject appends the desired OwnerReference to the object
func addOwnerRefToObject(obj metav1.Object, ownerRef metav1.OwnerReference) {
	// If Owner already in object, we ignore
	for _, o := range obj.GetOwnerReferences() {
		if o.UID == ownerRef.UID {
			return
		}
	}
	obj.SetOwnerReferences(append(obj.GetOwnerReferences(), ownerRef))
}

// asOwner returns an OwnerReference set as the memcached CR
func asOwner(d *webservicesv1a1.DrupalSite) metav1.OwnerReference {
	trueVar := true
	return metav1.OwnerReference{
		APIVersion: d.APIVersion,
		Kind:       d.Kind,
		Name:       d.Name,
		UID:        d.UID,
		Controller: &trueVar,
	}
}

// siteInstallJobForDrupalSite outputs the command needed for jobForDrupalSiteDrush
func siteInstallJobForDrupalSite() []string {
	// return []string{"sh", "-c", "echo"}
	return []string{"/operations/ensure-site-install.sh"}
}

// enableSiteMaintenanceModeCommandForDrupalSite outputs the command needed to enable maintenance mode
func enableSiteMaintenanceModeCommandForDrupalSite() []string {
	return []string{"/operations/enable-maintenance-mode.sh"}
}

// disableSiteMaintenanceModeCommandForDrupalSite outputs the command needed to disable maintenance mode
func disableSiteMaintenanceModeCommandForDrupalSite() []string {
	return []string{"/operations/disable-maintenance-mode.sh"}
}

// checkUpdbStatus outputs the command needed to check if a database update is required
func checkUpdbStatus() []string {
	return []string{"/operations/check-updb-status.sh"}
}

// runUpDBCommand outputs the command needed to update the database in drupal
func runUpDBCommand() []string {
	return []string{"/operations/run-updb.sh"}
}

// takeBackup outputs the command need to take the database backup to a given filename
func takeBackup(filename string) []string {
	return []string{"/operations/database-backup.sh", "-f", filename}
}

// restoreBackup outputs the command need to restore the database backup from a given filename
func restoreBackup(filename string) []string {
	return []string{"/operations/database-restore.sh", "-f", filename}
}

// cloneSource outputs the command need to clone a drupal site
func cloneSource(filename string) []string {
	return []string{"/operations/clone.sh", "-f", filename}
}

// encryptBasicAuthPassword encrypts a password for basic authentication
// Since we are using SabreDAV, the specific format to follow: https://sabre.io/dav/authentication/#using-the-file-backend
func encryptBasicAuthPassword(password string) string {
	webdavHashPrefix := webDAVDefaultLogin + ":SabreDAV:"
	hashedPassword := md5.Sum([]byte(webdavHashPrefix + password))
	return webdavHashPrefix + hex.EncodeToString(hashedPassword[:])
}

// checkIfSiteIsInstalled outputs the command to check if a site is initialized or not
func checkIfSiteIsInstalled() []string {
	return []string{"/operations/check-if-installed.sh"}
}

// cacheReload outputs the command to reload cache on the drupalSite
func cacheReload() []string {
	return []string{"/operations/clear-cache.sh"}
}

// syncDrupalFilesToEmptydir outputs the command to sync the files from /app to the emptyDir
func syncDrupalFilesToEmptydir() []string {
	return []string{"/operations/sync-drupal-emptydir.sh"}
}

// enableOrDisableRedis outputs the command to enable/ disable redis module for the site
func enableOrDisableRedis() []string {
	return []string{"/operations/enable-or-disable-redis.sh"}
}

// backupListUpdateNeeded tells whether two arrays of velero Backups elements are the same or not.
// A nil argument is equivalent to an empty slice.
func backupListUpdateNeeded(veleroBackupsList []velerov1.Backup, statusBackupsList []webservicesv1a1.Backup) bool {
	if len(veleroBackupsList) != len(statusBackupsList) {
		return true
	}
	for i, v := range veleroBackupsList {
		if v.Name != statusBackupsList[i].BackupName {
			return true
		}
	}
	return false
}

// updateBackupListStatus updates the list of backups in the status of the DrupalSite
func updateBackupListStatus(veleroBackupsList []velerov1.Backup) []webservicesv1a1.Backup {
	statusBackupsList := []webservicesv1a1.Backup{}
	for _, v := range veleroBackupsList {
		if value, bool := v.GetLabels()["drupal.webservices.cern.ch/drupalSite"]; bool {
			statusBackupsList = append(statusBackupsList, webservicesv1a1.Backup{BackupName: v.Name, DrupalSiteName: value, Date: v.Status.CompletionTimestamp, Expires: v.Status.Expiration})
		}
	}
	return statusBackupsList
}

// expectedDeploymentReplicas calculates expected replicas of deployment
func expectedDeploymentReplicas(currentnamespace *corev1.Namespace, qosClass webservicesv1a1.QoSClass) (int32, error) {
	_, isBlockedTimestampAnnotationSet := currentnamespace.Annotations["blocked.webservices.cern.ch/blocked-timestamp"]
	_, isBlockedReasonAnnotationSet := currentnamespace.Annotations["blocked.webservices.cern.ch/reason"]
	blocked := isBlockedTimestampAnnotationSet && isBlockedReasonAnnotationSet
	notBlocked := !isBlockedTimestampAnnotationSet && !isBlockedReasonAnnotationSet
	switch {
	case !blocked && !notBlocked:
		return 0, fmt.Errorf("both annotations blocked.webservices.cern.ch/blocked-timestamp and blocked.webservices.cern.ch/reason should be added/removed to block/unblock")
	case blocked:
		return 0, nil
	default:
		if qosClass == webservicesv1a1.QoSCritical {
			return 3, nil
		}
		return 1, nil
	}
}

// getDeploymentConfiguration precalculates all the configuration that the server deployment needs, including:
// pod replicas, resource req/lim
// NOTE: this includes the default resource limits for PHP
func (r *DrupalSiteReconciler) getDeploymentConfiguration(ctx context.Context, drupalSite *webservicesv1a1.DrupalSite) (config DeploymentConfig, requeue bool, updateStatus bool, reconcileErr reconcileError) {
	config = DeploymentConfig{}
	requeue = false
	updateStatus = false

	// Get replicas
	namespace := &corev1.Namespace{}
	if err := r.Get(ctx, types.NamespacedName{Name: drupalSite.Namespace}, namespace); err != nil {
		switch {
		case k8sapierrors.IsNotFound(err):
			return DeploymentConfig{}, true, false, nil
		default:
			return DeploymentConfig{}, false, false, newApplicationError(err, ErrClientK8s)
		}
	}
	replicas, err := expectedDeploymentReplicas(namespace, drupalSite.Spec.QoSClass)
	if err != nil {
		return DeploymentConfig{}, false, false, newApplicationError(err, ErrInvalidSpec)
	}
	if drupalSite.Status.ExpectedDeploymentReplicas == nil || *drupalSite.Status.ExpectedDeploymentReplicas != replicas {
		drupalSite.Status.ExpectedDeploymentReplicas = &replicas
		updateStatus = true
	}

	nginxResources, err := reqLimDict("nginx", drupalSite.Spec.QoSClass)
	if err != nil {
		reconcileErr = newApplicationError(err, ErrFunctionDomain)
	}
	phpExporterResources, err := reqLimDict("php-fpm-exporter", drupalSite.Spec.QoSClass)
	if err != nil {
		reconcileErr = newApplicationError(err, ErrFunctionDomain)
	}
	phpResources, err := reqLimDict("php-fpm", drupalSite.Spec.QoSClass)
	if err != nil {
		reconcileErr = newApplicationError(err, ErrFunctionDomain)
	}
	//TODO: Check best resource consumption
	webDAVResources, err := reqLimDict("webdav", drupalSite.Spec.QoSClass)
	if err != nil {
		reconcileErr = newApplicationError(err, ErrFunctionDomain)
	}
	redisResources, err := reqLimDict("redis", drupalSite.Spec.QoSClass)
	if err != nil {
		reconcileErr = newApplicationError(err, ErrFunctionDomain)
	}
	if reconcileErr != nil {
		return
	}

	// Get config override (currently only PHP resources)

	configOverride, reconcileErr := r.getConfigOverride(ctx, drupalSite)
	if reconcileErr != nil {
		return
	}
	if configOverride != nil {
		if !reflect.DeepEqual(configOverride.Php.Resources, corev1.ResourceRequirements{}) {
			phpResources = configOverride.Php.Resources
		}
		if !reflect.DeepEqual(configOverride.Nginx.Resources, corev1.ResourceRequirements{}) {
			nginxResources = configOverride.Nginx.Resources
		}
		if !reflect.DeepEqual(configOverride.Webdav.Resources, corev1.ResourceRequirements{}) {
			webDAVResources = configOverride.Webdav.Resources
		}
		if !reflect.DeepEqual(configOverride.PhpExporter.Resources, corev1.ResourceRequirements{}) {
			phpExporterResources = configOverride.PhpExporter.Resources
		}
	}

	config = DeploymentConfig{replicas: replicas,
		phpResources: phpResources, nginxResources: nginxResources, phpExporterResources: phpExporterResources, webDAVResources: webDAVResources, redisResources: redisResources,
	}
	return
}

type DeploymentConfig struct {
	replicas             int32
	phpResources         corev1.ResourceRequirements
	nginxResources       corev1.ResourceRequirements
	phpExporterResources corev1.ResourceRequirements
	webDAVResources      corev1.ResourceRequirements
	redisResources       corev1.ResourceRequirements
}

func (r *DrupalSiteReconciler) getConfigOverride(ctx context.Context, drp *webservicesv1a1.DrupalSite) (*webservicesv1a1.DrupalSiteConfigOverrideSpec, reconcileError) {
	configOverride := &webservicesv1a1.DrupalSiteConfigOverride{}
	err := r.Get(ctx, types.NamespacedName{Name: drp.Name, Namespace: drp.Namespace}, configOverride)
	switch {
	case k8sapierrors.IsNotFound(err):
		return nil, nil
	case err != nil:
		return nil, newApplicationError(err, ErrClientK8s)
	}
	return &configOverride.Spec, nil
}

// addOrRemoveRedisEnvironment adds or removes the redis environment variables like REDIS_SERVICE_HOST, REDIS_SERVICE_PORT and redis secret
// depending on the QoSClass
func addOrRemoveRedisEnvironment(container *v1.Container, drupalSite *webservicesv1a1.DrupalSite) error {
	if drupalSite.Spec.QoSClass == webservicesv1a1.QoSCritical {
		if !checkIfEnvVarExists(container.Env, "REDIS_SERVICE_HOST") {
			container.Env = append(container.Env, corev1.EnvVar{
				Name:  "REDIS_SERVICE_HOST",
				Value: "redis-" + drupalSite.Name,
			})
		}
		if !checkIfEnvVarExists(container.Env, "REDIS_SERVICE_PORT") {
			container.Env = append(container.Env, corev1.EnvVar{
				Name:  "REDIS_SERVICE_PORT",
				Value: "6379",
			})
		}
		if !checkIfEnvFromSourceExists(container.EnvFrom, "redis-"+drupalSite.Name) {
			container.EnvFrom = append(container.EnvFrom, corev1.EnvFromSource{
				SecretRef: &corev1.SecretEnvSource{
					LocalObjectReference: corev1.LocalObjectReference{
						Name: "redis-" + drupalSite.Name,
					},
				},
			})
		}
		// Sort the container's env var array
		// If we create an unsorted array, Kubernetes sorts it and there's a new reconciliation and new rollout of the deployment
		// Better to avoid that
		sort.Slice(container.Env, func(i, j int) bool {
			return container.Env[i].Name < container.Env[j].Name
		})
		sort.Slice(container.EnvFrom, func(i, j int) bool {
			return container.EnvFrom[i].SecretRef.Name < container.EnvFrom[j].SecretRef.Name
		})
	} else {
		for index := 0; index < len(container.Env); index++ {
			// index, value := range container.Env {
			value := container.Env[index]
			if value.Name == "REDIS_SERVICE_HOST" || value.Name == "REDIS_SERVICE_PORT" {
				container.Env = append(container.Env[:index], container.Env[index+1:]...)
			}
		}
		for index := 0; index < len(container.EnvFrom); index++ {
			// for index, value := range container.EnvFrom {
			value := container.EnvFrom[index]
			if value.SecretRef.Name == "redis-"+drupalSite.Name {
				container.EnvFrom = append(container.EnvFrom[:index], container.EnvFrom[index+1:]...)
			}
		}
	}
	return nil
}
